<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../common/frame-style.css">
  <title>Web GPU - Line Graph</title>
</head>
<body>
  <script type="module">
    import { initWebGPU } from '../common/webgpu/init.js';
    import * as geom from '../common/geom.js';


    const { canvas, adapter, device } = await initWebGPU();
    const context = canvas.getContext('webgpu');
    const presentationFormat = navigator.gpu.getPreferredCanvasFormat();

    context.configure({
      device,
      format: presentationFormat,
    });

    const numPoints = 100;
    const lineThickness = 0.02; // Thickness in clip space

    const vertices = new Float32Array(numPoints * 4); // 2 vertices * 2 coords
    try {
      const pos = new Float32Array(numPoints * 2);
      for (let i = 0; i < numPoints; i++) {
        const x = (i / (numPoints - 1)) * 2 - 1;
        const y = Math.sin(x * Math.PI * 2) * 0.5;

        pos[i*2 + 0] = x;
        pos[i*2 + 1] = y;
      }

      for (let i = 0; i < numPoints; i++) {
        let tangent;
        if (i === 0) {
          tangent = geom.v2Minus(pos, 1, 0);
        } else if (i === numPoints - 1) {
          tangent = geom.v2Minus(pos, i, i - 1);
        } else {
          tangent = geom.v2Minus(pos, i + 1, i - 1);
        }

        const norm = geom.v2Norm(tangent, 0);
        const perpX = -norm[0], perpY = norm[1];
        const [x, y] = geom.v2(pos, i);
        const offset = lineThickness / 2;
        vertices[i * 4 + 0] = x + perpX * offset;
        vertices[i * 4 + 1] = y + perpY * offset;
        vertices[i * 4 + 2] = x - perpX * offset;
        vertices[i * 4 + 3] = y - perpY * offset;
      }
    } catch (e) {
      console.error(e);
      throw e
    }

    const vertexBuffer = device.createBuffer({
      size: vertices.byteLength,
      usage: GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_DST,
    });
    device.queue.writeBuffer(vertexBuffer, 0, vertices);

    const pipeline = device.createRenderPipeline({
      layout: 'auto',
      vertex: {
        module: device.createShaderModule({
          code: `
            @vertex
            fn main(
              @location(0) position: vec2f
            ) -> @builtin(position) vec4f {
              return vec4f(position, 0.0, 1.0);
            }
          `,
        }),
        buffers: [
          {
            arrayStride: 8, // 2 floats * 4 bytes
            attributes: [
              {
                shaderLocation: 0,
                offset: 0,
                format: 'float32x2',
              },
            ],
          },
        ],
      },
      fragment: {
        module: device.createShaderModule({
          code: `
            @fragment
            fn main() -> @location(0) vec4f {
              return vec4f(0.0, 1.0, 0.0, 1.0); // Green line
            }
          `,
        }),
        targets: [
          {
            format: presentationFormat,
          },
        ],
      },
      primitive: {
        topology: 'triangle-strip',
      },
    });

    function frame() {
      const commandEncoder = device.createCommandEncoder();
      const textureView = context.getCurrentTexture().createView();

      const renderPassDescriptor = {
        colorAttachments: [
          {
            view: textureView,
            clearValue: [0.1, 0.1, 0.1, 1.0], // Dark gray background
            loadOp: 'clear',
            storeOp: 'store',
          },
        ],
      };

      const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
      passEncoder.setPipeline(pipeline);
      passEncoder.setVertexBuffer(0, vertexBuffer);
      passEncoder.draw(numPoints * 2); // 2 vertices per point for triangle strip
      passEncoder.end();

      device.queue.submit([commandEncoder.finish()]);
      requestAnimationFrame(frame);
    }

    requestAnimationFrame(frame);
  </script>
</body>
</html>
