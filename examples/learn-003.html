<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../common/frame-style.css">
  <title>Web GPU - Line Graph</title>
</head>
<body>
  <script type="module">
    import * as csv from '../common/data/csv.js';
    import { wbPopulation, ituCellPhones } from '../common/data/datasets.js';
    import { initWebGPU } from '../common/init.js';

    const UNIFORM_INIT = {
      alpha: 2/3,
      saving: 0.4,
      depreciation: 0.07,
    };

    try {
      const [size, groups, df] = await setupData();
      const { canvas, adapter, device } = await initWebGPU();

      device.pushErrorScope('validation');

      const { COPY_DST, COPY_SRC } = GPUBufferUsage;
      const phoneUsageBuffer = createBuffer(device, df.phoneUsage, COPY_DST);
      const prevTechnologyBuffer = createBuffer(device, df.initialTech, COPY_DST);
      const technologyBuffer = createBuffer(device, df.technology, COPY_SRC | COPY_DST);
      const capitalSteadyStateBuffer = createBuffer(device, df.capitalSteadyState, COPY_SRC | COPY_DST);

      const shaderCode = document.getElementById('compute-shader').textContent;
      const shaderModule = device.createShaderModule({ code: shaderCode });
      const commandEncoder = device.createCommandEncoder();

      const step1 = createStep({
        device,
        shaderModule,
        commandEncoder,
        bindGroup: 0,
        workGroups: size,
        entryPoint: 'step1',
        entries: [
          { binding: 0, resource: { buffer: phoneUsageBuffer } },
          { binding: 1, resource: { buffer: prevTechnologyBuffer } },
          { binding: 2, resource: { buffer: technologyBuffer } },
        ],
      });

      const step2 = createStep({
        device,
        shaderModule,
        commandEncoder,
        bindGroup: 0,
        workGroups: Math.ceil(size / 64),
        entryPoint: 'step2',
        entries: [
          { binding: 0, resource: { buffer: technologyBuffer } },
          { binding: 1, resource: { buffer: capitalSteadyStateBuffer } },
        ],
      });

      const pass = commandEncoder.beginComputePass();
      step1.loadIntoPass(pass);
      step2.loadIntoPass(pass);
      pass.end();

      const mapping1 = createMapping(device, commandEncoder, technologyBuffer, df.technology);
      const mapping2 = createMapping(device, commandEncoder, capitalSteadyStateBuffer, df.capitalSteadyState);
      device.queue.submit([commandEncoder.finish()]);
      await mapping1.read();
      await mapping2.read();

      console.log('Technology results:', df.technology.slice(0, 10));
      console.log('Capital steady state results:', df.capitalSteadyState.slice(0, 10));

      const errorScope = await device.popErrorScope();
      if (errorScope) {
        console.error('GPU:',errorScope.message);
        console.info(errorScope);
      }
    } catch (e) {
      console.error(e);
    }

    function createBuffer(device, data, flag) {
      const buffer = device.createBuffer({
        size: data.length * data.constructor.BYTES_PER_ELEMENT,
        usage: GPUBufferUsage.STORAGE | flag,
      });
      device.queue.writeBuffer(buffer, 0, data);
      return buffer;
    }

    function createStep({
      device,
      shaderModule,
      entryPoint,
      entries,
      bindGroup: bindGroupId,
      workGroups,
    }) {
      const pipeline = device.createComputePipeline({
        layout: 'auto',
        compute: {
          module: shaderModule,
          entryPoint,
        },
      });

      const bindGroup = device.createBindGroup({
        layout: pipeline.getBindGroupLayout(bindGroupId),
        entries,
      });

      const loadIntoPass = pass => {
        pass.setPipeline(pipeline);
        pass.setBindGroup(bindGroupId, bindGroup);
        pass.dispatchWorkgroups(workGroups);
      };

      return { loadIntoPass, pipeline, pipeline, bindGroupId };
    }

    function createMapping(device, commandEncoder, buffer, out) {
      const ArrayConst = out.constructor
      const bufferSize = out.length * ArrayConst.BYTES_PER_ELEMENT;
      const stagingBuffer = device.createBuffer({
        size: bufferSize,
        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
      });

      commandEncoder.copyBufferToBuffer(
        buffer, 0,
        stagingBuffer, 0,
        bufferSize
      );

      const read = async () => {
        await stagingBuffer.mapAsync(GPUMapMode.READ);
        out.set(new ArrayConst(stagingBuffer.getMappedRange()));
        stagingBuffer.unmap();
      };

      return { read, stagingBuffer };
    }

    /**
     * Setup data for processing
     */
    async function setupData() {
      const [
        wbPop,
        ituPhone,
      ] = await Promise.all([
        (
          fetch(wbPopulation.url)
            .then(r => r.text())
            .then(t => csv.processCsv(t, {
              headers: wbPopulation.headers.load,
              dropRows: wbPopulation.dropRows,
            }))
            .then([size, df] => csv.wideToLong(
              df,
              wbPopulation.long.retain,
              wbPopulation.long.colout,
            ))
        ),
        (
          fetch(ituCellPhones.url)
            .then(r => r.text())
            .then(t => csv.processCsv(t, {
              headers: ituCellPhones.headers
            }))
        ),
      ]);

      const size = ituPhone.size;

      csv.renameColumn(ituPhone.df, 'value', 'phoneUsage');
      ituPhone.groups = csv.sortAndIdentifyGroups('countryId', 'year', ituPhone.df);

      // Exogenous, will populate later
      ituPhone.df.labour = new Float64Array(size);

      // Computed in first step
      ituPhone.df.technology = new Float64Array(size);
      ituPhone.df.initialTech = new Float64Array(size);

      // Computed in second step
      ituPhone.df.capitalSteadyState = new Float64Array(size);

      // Computed in third step
      ituPhone.df.capital = new Float64Array(size);
      ituPhone.df.output = new Float64Array(size);

      for (let i = 0; i < size; i++) {
        ituPhone.df.labour[i] = 1;
        ituPhone.df.initialTech[i] = 1_000_000;
      }

      return [size, ituPhone.groups, ituPhone.df];
    }
  </script>
  <script type="text/wgsl" id="compute-shader">
    @group(0) @binding(0) var<storage, read> phoneUsage: array<f32>;
    @group(0) @binding(1) var<storage, read> prevTechnology: array<f32>;
    @group(0) @binding(2) var<storage, read_write> technology: array<f32>;

    @compute @workgroup_size(1)
    fn step1(@builtin(global_invocation_id) global_id: vec3<u32>) {
      let idx = global_id.x;
      technology[idx] = phoneUsage[idx] * prevTechnology[idx];
    }


    @group(0) @binding(0) var<storage, read> technologyInput: array<f32>;
    @group(0) @binding(1) var<storage, read_write> capitalSteadyState: array<f32>;

    @compute @workgroup_size(64)
    fn step2(@builtin(global_invocation_id) global_id: vec3<u32>) {
      let idx = global_id.x;
      capitalSteadyState[idx] = technologyInput[idx];
    }
  </script>
</body>
</html>
