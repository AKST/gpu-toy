<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="application-name" content="TFP Growth Model" lang="en" />
  <meta name="description" content="Compute a TFP growth model based on phone adoption via WebGPU">
  <link rel="stylesheet" href="../common/frame-style.css">
  <title>Web GPU - Line Graph</title>
</head>
<body>
  <script>
    window.addEventListener('error', event => console.error(event.error));
    window.addEventListener('unhandledrejection', event => console.error(event.error));

    if (window.parent == null) alert('note this page was designed to run in an iframe');
  </script>
  <script type="module">
    import * as csv from '../common/data/csv.js';
    import * as datasets from '../common/data/datasets.js';
    import { initWebGPU } from '../common/webgpu/init.js';
    import { createBuffer, createStep, createMapping } from '../common/webgpu/setup.js';
    import { UniformAdapter } from '../common/webgpu/uniforms.js';

    const INITIAL_TECH = 1_000;


    const uniformCfg = UniformAdapter.create([
      { size: 4, init: 25, name: 'year_per_country' },
    ]);

    const uniformExo = UniformAdapter.create([
      { size: 4, init: 2/3, name: 'alpha' },
      { size: 4, init: 0.9, name: 'saving' },
      { size: 4, init: 0.07, name: 'depreciation' },
      { size: 4, init: INITIAL_TECH, name: 'tech_init' },
    ]);

    const uniformEff = UniformAdapter.create([
      { size: 4, init: 0.001, name: 'phoneEffect' },
      { size: 4, init: 0.001, name: 'phoneInternet' },
    ]);

    window.addEventListener('message', onMessage);
    window.parent?.postMessage({
      kind: 'register-button',
      label: 'Download Inputs',
      id: 'download',
    });

    window.parent?.postMessage({
      kind: 'register-knobs',
      knobs: [
        { name: 'alpha', label: 'Alpha', init: 2/3 },
        { name: 'saving', label: 'Savings Rate', init: 0.4 },
        { name: 'deprecation', label: 'Deprecation Rate', init: 0.07 },
        { name: 'phoneEffect', label: 'ùõΩ Phone Effect', init: 0.001 },
        { name: 'phoneInternet', label: 'ùõΩ Internet Effect', init: 0.001 },
      ],
    });

    const { canvas, adpater, device } = await initWebGPU();
    const [size, groups, df, inits] = await setupData();
    showLog('Observations:', csv.getSize(df));
    showLog('Countries:', groups.groupValues.length);
    showLog('Nation Offsets', [...inits.offsets]);

    device.pushErrorScope('validation');

    const { COPY_DST, COPY_SRC } = GPUBufferUsage;
    const bufferNationOffset = createBuffer(device, inits.offsets, COPY_DST);
    const bufferNationCapitalInit = createBuffer(device, inits.capital, COPY_DST);

    // Combined output buffer: struct has 4 f32s per row (technology, capital, capital_steady_state, output)
    const combinedOutputData = new Float32Array(size * 4);
    const bufferCombinedOutput = createBuffer(device, combinedOutputData, COPY_SRC | COPY_DST);

    const bufferPhoneUsage = createBuffer(device, df.phoneUsageD, COPY_DST);
    const bufferPhoneInternet = createBuffer(device, df.phoneInternetD, COPY_DST);
    const bufferUnemployment = createBuffer(device, df.unemployment, COPY_DST);
    const bufferLabourForce = createBuffer(device, df.labourForce, COPY_DST);
    const bufferUnifExo = uniformExo.createBuffer(device);
    const bufferUnifEff = uniformEff.createBuffer(device);
    const bufferUnifCfg = uniformCfg.createBuffer(device);

    const uniformBindGrp = [
      { binding: 0, resource: { buffer: bufferUnifExo } },
      { binding: 1, resource: { buffer: bufferUnifEff } },
    ];

    const shaderCode = document.getElementById('compute-shader').textContent;
    const shaderModule = device.createShaderModule({ code: shaderCode });

    const step1 = createStep({
      device,
      shaderModule,
      uniforms: [
        { binding: 0, resource: { buffer: bufferUnifExo } },
        { binding: 1, resource: { buffer: bufferUnifEff } },
        { binding: 2, resource: { buffer: bufferUnifCfg } },
      ],
      workGroups: inits.size,
      entryPoint: 'step1',
      entries: [
        { binding: 0, resource: { buffer: bufferNationOffset } },
        { binding: 1, resource: { buffer: bufferNationCapitalInit } },

        { binding: 10, resource: { buffer: bufferCombinedOutput } },

        { binding: 20, resource: { buffer: bufferPhoneUsage } },
        { binding: 21, resource: { buffer: bufferPhoneInternet } },

        { binding: 30, resource: { buffer: bufferUnemployment } },
        { binding: 31, resource: { buffer: bufferLabourForce } },
      ],
    });

    const step2 = createStep({
      device,
      shaderModule,
      uniforms: [
        { binding: 0, resource: { buffer: bufferUnifExo } },
      ],
      workGroups: Math.ceil(size / 64),
      entryPoint: 'step2',
      entries: [
        { binding: 10, resource: { buffer: bufferCombinedOutput } },
        { binding: 30, resource: { buffer: bufferUnemployment } },
        { binding: 31, resource: { buffer: bufferLabourForce } },
      ],
    });

    // await runGPU();

    const errorScope = await device.popErrorScope();
    if (errorScope) {
      console.error('GPU:',errorScope.message);
      console.info(errorScope);
    }

    async function runGPU() {
      try {
        const commandEncoder = device.createCommandEncoder();
        const pass = commandEncoder.beginComputePass();
        step1.loadIntoPass(pass);
        step2.loadIntoPass(pass);
        pass.end();

        const mapping = createMapping(
          device,
          commandEncoder,
          bufferCombinedOutput,
          combinedOutputData,
        );

        device.queue.submit([commandEncoder.finish()]);
        await mapping.read();

        for (let i = 0; i < size; i++) {
          df.technology[i] = combinedOutputData[i * 4 + 0];
          df.capital[i] = combinedOutputData[i * 4 + 1];
          df.capitalSteadyState[i] = combinedOutputData[i * 4 + 2];
          df.output[i] = combinedOutputData[i * 4 + 3];
        }

        showLog('Technology results:', [...df.technology.slice(0, 10)]);
        showLog('Capital steady state results:', [...df.capitalSteadyState.slice(0, 10)]);
        console.info(df, groups);
      } catch (e) {
        console.error(e);
      }
    }

    async function onMessage(event) {
      try {
        const message = event.data;
        switch (message.kind) {
          case 'action':
            return await onAction(message);

          case 'update-knobs':
            return updateUniforms(message.data)

          default:
            return console.log('unknown message', message);
        }
      } catch (e) {
        console.error(e);
      }
    }

    function updateUniforms(data) {
      uniformExo.update('alpha', data.alpha);
      uniformExo.update('saving', data.saving);
      uniformExo.update('depreciation', data.depreciation);
      uniformEff.update('phoneEffect', data.phoneEffect);
      uniformEff.update('phoneInternet', data.phoneInternet);
      uniformExo.updateBuffer(device, bufferUnifExo);
      uniformEff.updateBuffer(device, bufferUnifEff);
      runGPU();
    }

    async function onAction(message) {
      switch (message.id) {
        case 'download':
          return await csv.downloadFile(
            csv.renameColumn(
              csv.dropColumn(df, [
                'countryId',
                'technology',
                'initialTech',
                'capitalSteadyState',
                'capital',
                'output',
              ]),
              {
                generatedData: 'faked_askAngusWhatThatMeans',
                phoneUsageD: 'difference_in_phoneUsage',
                phoneInternetD: 'difference_in_phoneInternet',
              },
            ),
            'model-inputs.csv',
          );

        default:
          return console.log('unknown action', message);
      }
    }

    function showLog(...args) {
      window.parent?.postMessage({ kind: 'push-log', log: args });
    }

    /**
     * Setup data for processing
     */
    async function setupData() {
      const fetching = {
        loadWideData(cfg) {
          return fetch(cfg.url)
              .then(r => r.text())
              .then(t => csv.processCsv(t, {
                headers: cfg.headers.load,
                dropRows: cfg.dropRows ?? 0,
              }))
              .then(df => {
                const { retain, colout } = cfg.headers.long;
                return csv.wideToLong(df, retain, colout);
              })
        },
        loadLongData(cfg) {
          return fetch(cfg.url)
              .then(r => r.text())
              .then(t => csv.processCsv(t, {
                headers: cfg.headers,
                dropRows: cfg.dropRows ?? 0,
              }))
        },
        loadItuData(cfg) {
          return fetching.loadLongData(cfg)
              .then(df => csv.filter(df, 'seriesCode', y => y === cfg.seriesCode))
              .then(df => csv.dropColumn(df, 'seriesCode'))
              .then(df => csv.renameColumn(df, { value: cfg.dataName }))
        },
      };

      const columnsThatNeedCleaning = [
        'capitalPPP', 'labourForce', 'phoneInternet',
        'phoneUsage', 'population', 'unemployment',
      ];
      const columnsThatNeedRepeating = ['countryId', 'countryIso', 'countryName'];

      const [
        ituPhone,
        ituMobileInternet,
        wbPop,
        wbLabourForce,
        wbUnemployment,
        pwtStock,
      ] = await Promise.all([
        fetching.loadItuData(datasets.ituCellPhones),
        fetching.loadItuData(datasets.ituMobileBoardBandSubcriptions),
        fetching.loadWideData(datasets.wbPopulation),
        fetching.loadWideData(datasets.wbLabourForce),
        fetching.loadWideData(datasets.wbUnemployment),
        fetching.loadWideData(datasets.pwtCapitalStock),
      ]);

      let join = csv.outerJoins(
        [ituPhone, ituMobileInternet, wbPop, wbLabourForce, wbUnemployment, pwtStock],
        ['countryIso', 'year'],
      );
      join = csv.filter(join, 'year', year => !Number.isNaN(year) && year > 1999);
      let joinGroup = csv.sortAndIdentifyGroups('countryIso', 'year', join);
      joinGroup = csv.filterGroups(joinGroup, { uniformSize: true }, meta => {
        if (meta.max < 2012 || meta.count < 10) return false;

        const join = joinGroup.frame;
        const { count, offset } = meta;
        for (const colname of columnsThatNeedCleaning) {
          const input = join[colname];
          let nans = 0;
          for (let i = 0; i < count; i++) {
            if (Number.isNaN(input[offset + i])) nans += 1;
          }
          if (nans >= (count - nans)) return false;
        }

        return true;
      });


      joinGroup = csv.sortAndIdentifyGroups('countryIso', 'year', joinGroup.frame);
      join = joinGroup.frame;

      const size = csv.getSize(join);
      join.technology = new Float32Array(size);
      join.initialTech = new Float32Array(size);
      join.capitalSteadyState = new Float32Array(size);
      join.capital = new Float32Array(size);
      join.output = new Float32Array(size);

      join.phoneUsageD = new Float32Array(size);
      join.phoneInternetD = new Float32Array(size);
      join.generatedData = new Array(size).fill('');

      /**
       * Clean up the data may not be complete
       */
      for (const colname of columnsThatNeedCleaning) {
        const input = join[colname];
        for (const [groupValue, { offset, count }] of joinGroup.groups.entries()) {
          if (Number.isNaN(input[offset])) {
            input[offset] = 0;
            join.generatedData[offset] += ':'+colname
          }
          for (let i = 1; i < count; i++) {
            let idx = offset + i;
            if (Number.isNaN(input[idx])) {
              join.generatedData[idx] += ':'+colname
              input[idx] = input[idx-1];
              if (Number.isNaN(input[idx])) debugger;
            }
          }
        }
      }

      for (const [diff, sum] of [
        [join.phoneUsageD, join.phoneUsage],
        [join.phoneInternetD, join.phoneInternet],
      ]) {
        for (const [groupValue, { offset, count }] of joinGroup.groups.entries()) {
          diff[offset] = sum[offset];
          for (let i = 1; i < count; i++) {
            diff[offset + i] = sum[offset + i] - sum[offset + i - 1];
          }
        }
      }

      for (let i = 0; i < size; i++) {
        join.initialTech[i] = INITIAL_TECH;
      }

      const initCapital = Array.from(joinGroup.groups.keys(), country => {
        const index = csv.findIndex(pwtStock, [
          ['year', year => year === 1999],
          ['countryIso', iso => iso === country],
        ]);
        return pwtStock.capitalPPP[index];
      });

      const offsets = Array.from(joinGroup.groups.values(), row => row.offset);

      const initalValues = {
        capital: new Float32Array(initCapital),
        offsets: new Uint32Array(offsets),
        size: offsets.length,
      };
      return [size, joinGroup, join, initalValues];
    }
  </script>
  <script type="text/wgsl" id="compute-shader">
    struct Config {
      yearsPerCountry: u32,
    };

    struct Effects {
      phone_fixed: f32,
      net_exp: f32,
    };

    struct ExogenousState {
      alpha: f32,
      saving: f32,
      depreciation: f32,
      tech_init: f32,
    };

    struct ComputedState {
      technology: f32,
      capital: f32,
      capital_steady_state: f32,
      output: f32,
    }

    @group(1) @binding(0) var<uniform> exo: ExogenousState;
    @group(1) @binding(1) var<uniform> effects: Effects;
    @group(1) @binding(2) var<uniform> config: Config;

    @group(0) @binding(0) var<storage, read> offsets: array<u32>;
    @group(0) @binding(1) var<storage, read> capital_init: array<f32>;

    @group(0) @binding(10) var<storage, read_write> out: array<ComputedState>;

    @group(0) @binding(20) var<storage, read> growth_phoneuse: array<f32>;
    @group(0) @binding(21) var<storage, read> growth_netuse: array<f32>;
    @group(0) @binding(30) var<storage, read> unemployment: array<f32>;
    @group(0) @binding(31) var<storage, read> labourForce: array<f32>;

    /**
     * Computes technology over the different periods
     */
    @compute @workgroup_size(1)
    fn step1(@builtin(global_invocation_id) global_id: vec3<u32>) {
      let offset = offsets[global_id.x];
      var k_last = capital_init[global_id.x];
      var t_last = exo.tech_init;
      var y_last = 1.0;

      for (var i = 0u; i < config.yearsPerCountry; i++) {
        let idx = offset + i;

        let t_growth_phone = growth_phoneuse[idx] * effects.phone_fixed;
        let t_growth_net = growth_netuse[idx] * effects.net_exp;
        let t_next = t_growth_phone + t_growth_net + t_last;
        let l_next = labourForce[idx] * (1 - unemployment[idx]);
        let k_next = (exo.saving * y_last) - (exo.depreciation * k_last);
        let y_next = t_next * pow(l_next, exo.alpha) * pow(k_next, 1 - exo.alpha);

        y_last = y_next;
        k_last = k_next;
        t_last = t_next;

        out[idx].output = y_next;
        out[idx].capital = k_next;
        out[idx].technology = t_next;
      }
    }

    @compute @workgroup_size(64)
    fn step2(@builtin(global_invocation_id) global_id: vec3<u32>) {
      let idx = global_id.x;
      let a = exo.alpha * out[idx].technology;
      let l = labourForce[idx] * (1 - unemployment[idx]);
      out[idx].capital_steady_state = a * l;
    }
  </script>
</body>
</html>
