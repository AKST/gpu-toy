<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../common/frame-style.css">
  <title>Web GPU - Line Graph</title>
</head>
<body>
  <script type="module">
    import * as csv from '../common/data/csv.js';
    import * as datasets from '../common/data/datasets.js';
    import { initWebGPU } from '../common/init.js';
    import { UniformAdapter } from '../common/webgpu/uniforms.js';

    const uniforms = UniformAdapter.create([
      { size: 4, init: 2/3, name: 'alpha' },
      { size: 4, init: 0.4, name: 'saving' },
      { size: 4, init: 0.07, name: 'depreciation' },
    ]);

    try {
      const [size, groups, df] = await setupData();
      const { canvas, adapter, device } = await initWebGPU();

      device.pushErrorScope('validation');

      const { COPY_DST, COPY_SRC } = GPUBufferUsage;
      const phoneUsageBuffer = createBuffer(device, df.phoneUsage, COPY_DST);
      const prevTechnologyBuffer = createBuffer(device, df.initialTech, COPY_DST);
      const technologyBuffer = createBuffer(device, df.technology, COPY_SRC | COPY_DST);
      const capitalSteadyStateBuffer = createBuffer(device, df.capitalSteadyState, COPY_SRC | COPY_DST);
      const uniformBuffer = uniforms.createBuffer(device);

      const shaderCode = document.getElementById('compute-shader').textContent;
      const shaderModule = device.createShaderModule({ code: shaderCode });
      const commandEncoder = device.createCommandEncoder();

      const step1 = createStep({
        device,
        shaderModule,
        commandEncoder,
        //uniforms: uniformBuffer,
        workGroups: size,
        entryPoint: 'step1',
        entries: [
          { binding: 0, resource: { buffer: phoneUsageBuffer } },
          { binding: 1, resource: { buffer: prevTechnologyBuffer } },
          { binding: 2, resource: { buffer: technologyBuffer } },
        ],
      });

      const step2 = createStep({
        device,
        shaderModule,
        commandEncoder,
        uniforms: uniformBuffer,
        workGroups: Math.ceil(size / 64),
        entryPoint: 'step2',
        entries: [
          { binding: 0, resource: { buffer: technologyBuffer } },
          { binding: 1, resource: { buffer: capitalSteadyStateBuffer } },
        ],
      });

      const pass = commandEncoder.beginComputePass();
      step1.loadIntoPass(pass);
      step2.loadIntoPass(pass);
      pass.end();

      const mapping1 = createMapping(device, commandEncoder, technologyBuffer, df.technology);
      const mapping2 = createMapping(device, commandEncoder, capitalSteadyStateBuffer, df.capitalSteadyState);
      device.queue.submit([commandEncoder.finish()]);
      await mapping1.read();
      await mapping2.read();

      console.log('Technology results:', df.technology.slice(0, 10));
      console.log('Capital steady state results:', df.capitalSteadyState.slice(0, 10));

      const errorScope = await device.popErrorScope();
      if (errorScope) {
        console.error('GPU:',errorScope.message);
        console.info(errorScope);
      }
    } catch (e) {
      console.error(e);
    }

    function createBuffer(device, data, flag) {
      const buffer = device.createBuffer({
        size: data.length * data.constructor.BYTES_PER_ELEMENT,
        usage: GPUBufferUsage.STORAGE | flag,
      });
      device.queue.writeBuffer(buffer, 0, data);
      return buffer;
    }

    function createStep({
      device,
      shaderModule,
      entryPoint,
      entries,
      workGroups,
      uniforms,
    }) {
      const pipeline = device.createComputePipeline({
        layout: 'auto',
        compute: {
          module: shaderModule,
          entryPoint,
        },
      });

      const bindGroup = device.createBindGroup({
        layout: pipeline.getBindGroupLayout(0),
        entries,
      });

      const bindGroupUniform = uniforms && device.createBindGroup({
        layout: pipeline.getBindGroupLayout(1),
        entries: [{ binding: 0, resource: { buffer: uniforms } }],
      });

      const loadIntoPass = pass => {
        pass.setPipeline(pipeline);
        pass.setBindGroup(0, bindGroup);
        if (bindGroupUniform) {
          pass.setBindGroup(1, bindGroupUniform);
        }
        pass.dispatchWorkgroups(workGroups);
      };

      return { loadIntoPass, pipeline, bindGroup, bindGroupUniform };
    }

    function createMapping(device, commandEncoder, buffer, out) {
      const ArrayConst = out.constructor
      const bufferSize = out.length * ArrayConst.BYTES_PER_ELEMENT;
      const stagingBuffer = device.createBuffer({
        size: bufferSize,
        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
      });

      commandEncoder.copyBufferToBuffer(
        buffer, 0,
        stagingBuffer, 0,
        bufferSize
      );

      const read = async () => {
        await stagingBuffer.mapAsync(GPUMapMode.READ);
        out.set(new ArrayConst(stagingBuffer.getMappedRange()));
        stagingBuffer.unmap();
      };

      return { read, stagingBuffer };
    }

    /**
     * Setup data for processing
     */
    async function setupData() {
      function loadWideData(cfg) {
        return fetch(cfg.url)
            .then(r => r.text())
            .then(t => csv.processCsv(t, {
              headers: cfg.headers.load,
              dropRows: cfg.dropRows ?? 0,
            }))
            .then(df => {
              const { retain, colout } = cfg.headers.long;
              return csv.wideToLong(df, retain, colout);
            })
            .then(df => csv.filter(df, 'year', y => y >= 2000))
      }

      function loadLongData(cfg) {
        return fetch(cfg.url)
            .then(r => r.text())
            .then(t => csv.processCsv(t, {
              headers: cfg.headers,
              dropRows: cfg.dropRows ?? 0,
            }))
      }

      const [
        ituPhone,
        wbPop,
        wbLabourForce,
        wbUnemployment,
        pwtStock,
      ] = await Promise.all([
        (
          loadLongData(datasets.ituCellPhones)
            .then(df => csv.filter(df, 'seriesCode', y => y === 'i271'))
            .then(df => csv.dropColumn(df, 'seriesCode'))
            .then(df => csv.renameColumn(df, 'value', 'phoneUsage'))
        ),
        loadWideData(datasets.wbPopulation),
        loadWideData(datasets.wbLabourForce).then(df => {
          return csv.filter(df, 'labourForce', lf => !Number.isNaN(lf));
        }),
        loadWideData(datasets.wbUnemployment).then(df => {
          return csv.filter(df, 'unemployment', lf => !Number.isNaN(lf));
        }),
        loadWideData(datasets.pwtCapitalStock),
      ]);

      const join = csv.innerJoins(
        [ituPhone, wbPop, wbLabourForce, wbUnemployment, pwtStock],
        ['countryIso', 'year'],
      );
      const joinGroup = csv.sortAndIdentifyGroups('countryIso', 'year', join);
      const size = csv.getSize(join);

      console.log(joinGroup);

      join.labour = new Float32Array(size);
      join.technology = new Float32Array(size);
      join.initialTech = new Float32Array(size);
      join.capitalSteadyState = new Float32Array(size);
      join.capital = new Float32Array(size);
      join.output = new Float32Array(size);

      for (let i = 0; i < size; i++) {
        join.labour[i] = 1;
        join.initialTech[i] = 1_000_000;
      }

      return [size, joinGroup, join];
    }
  </script>
  <script type="text/wgsl" id="compute-shader">
    struct ExogenousState {
      alpha: f32,
      saving: f32,
      depreciation: f32,
    };

    @group(1) @binding(0) var<uniform> exogenous: ExogenousState;

    @group(0) @binding(0) var<storage, read> phoneUsage: array<f32>;
    @group(0) @binding(1) var<storage, read> prevTechnology: array<f32>;
    @group(0) @binding(2) var<storage, read_write> technology: array<f32>;

    /**
     * Computes technology over the different periods
     */
    @compute @workgroup_size(1)
    fn step1(@builtin(global_invocation_id) global_id: vec3<u32>) {
      let idx = global_id.x;
      technology[idx] = phoneUsage[idx] * prevTechnology[idx];
    }


    @group(0) @binding(0) var<storage, read> technologyInput: array<f32>;
    @group(0) @binding(1) var<storage, read_write> capitalSteadyState: array<f32>;

    @compute @workgroup_size(64)
    fn step2(@builtin(global_invocation_id) global_id: vec3<u32>) {
      let idx = global_id.x;
      capitalSteadyState[idx] = exogenous.alpha * technologyInput[idx];
    }
  </script>
</body>
</html>
