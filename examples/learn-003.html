<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../common/frame-style.css">
  <title>Web GPU - Line Graph</title>
</head>
<body>
  <script type="module">
    import * as csv from '../common/data/csv.js';
    import * as datasets from '../common/data/datasets.js';
    import { initWebGPU } from '../common/init.js';
    import { UniformAdapter } from '../common/webgpu/uniforms.js';

    const INITIAL_TECH = 1_000;

    const uniformExo = UniformAdapter.create([
      { size: 4, init: 2/3, name: 'alpha' },
      { size: 4, init: 0.4, name: 'saving' },
      { size: 4, init: 0.07, name: 'depreciation' },
    ]);

    const uniformEff = UniformAdapter.create([
      { size: 4, init: 0.001, name: 'phoneEffect' },
      { size: 4, init: 0.001, name: 'phoneInternet' },
    ]);

    try {
      const [size, groups, df] = await setupData();
      const { canvas, adapter, device } = await initWebGPU();

      device.pushErrorScope('validation');

      const { COPY_DST, COPY_SRC } = GPUBufferUsage;
      const bufferPhoneUsage = createBuffer(device, df.phoneUsageD, COPY_DST);
      const bufferPhoneInternet = createBuffer(device, df.phoneInternetD, COPY_DST);
      const bufferPrevTechnology = createBuffer(device, df.initialTech, COPY_DST);
      const bufferTechnology = createBuffer(device, df.technology, COPY_SRC | COPY_DST);
      const bufferOutput = createBuffer(device, df.output, COPY_SRC | COPY_DST);
      const bufferCapitalSteadyState = createBuffer(device, df.capitalSteadyState, COPY_SRC | COPY_DST);
      const bufferUnemployment = createBuffer(device, df.unemployment, COPY_DST);
      const bufferLabourForce = createBuffer(device, df.labourForce, COPY_DST);
      const bufferUnifExo = uniformExo.createBuffer(device);
      const bufferUnifEff = uniformEff.createBuffer(device);

      const uniformBindGrp = [
        { binding: 0, resource: { buffer: bufferUnifExo } },
        { binding: 1, resource: { buffer: bufferUnifEff } },
      ];

      const shaderCode = document.getElementById('compute-shader').textContent;
      const shaderModule = device.createShaderModule({ code: shaderCode });
      const commandEncoder = device.createCommandEncoder();

      const step1 = createStep({
        device,
        shaderModule,
        commandEncoder,
        uniforms: uniformBindGrp,
        workGroups: size,
        entryPoint: 'step1',
        entries: [
          { binding: 0, resource: { buffer: bufferTechnology } },
          { binding: 1, resource: { buffer: bufferOutput } },
          { binding: 2, resource: { buffer: bufferPhoneUsage } },
          { binding: 3, resource: { buffer: bufferPhoneInternet } },
          { binding: 4, resource: { buffer: bufferPrevTechnology } },
          { binding: 5, resource: { buffer: bufferUnemployment } },
          { binding: 6, resource: { buffer: bufferLabourForce } },
        ],
      });

      const step2 = createStep({
        device,
        shaderModule,
        commandEncoder,
        uniforms: uniformBindGrp,
        workGroups: Math.ceil(size / 64),
        entryPoint: 'step2',
        entries: [
          { binding: 0, resource: { buffer: bufferCapitalSteadyState } },
          { binding: 1, resource: { buffer: bufferTechnology } },
          { binding: 5, resource: { buffer: bufferUnemployment } },
          { binding: 6, resource: { buffer: bufferLabourForce } },
        ],
      });

      const pass = commandEncoder.beginComputePass();
      step1.loadIntoPass(pass);
      step2.loadIntoPass(pass);
      pass.end();

      const mapping1 = createMapping(device, commandEncoder, bufferTechnology, df.technology);
      const mapping2 = createMapping(device, commandEncoder, bufferCapitalSteadyState, df.capitalSteadyState);
      device.queue.submit([commandEncoder.finish()]);
      await mapping1.read();
      await mapping2.read();

      console.log('Technology results:', df.technology.slice(0, 10));
      console.log('Capital steady state results:', df.capitalSteadyState.slice(0, 10));
      console.log(df);

      const errorScope = await device.popErrorScope();
      if (errorScope) {
        console.error('GPU:',errorScope.message);
        console.info(errorScope);
      }
    } catch (e) {
      console.error(e);
    }

    function createBuffer(device, data, flag) {
      const buffer = device.createBuffer({
        size: data.length * data.constructor.BYTES_PER_ELEMENT,
        usage: GPUBufferUsage.STORAGE | flag,
      });
      device.queue.writeBuffer(buffer, 0, data);
      return buffer;
    }

    function createStep({
      device,
      shaderModule,
      entryPoint,
      entries,
      workGroups,
      uniforms,
    }) {
      const pipeline = device.createComputePipeline({
        layout: 'auto',
        compute: {
          module: shaderModule,
          entryPoint,
        },
      });

      const bindGroup = device.createBindGroup({
        layout: pipeline.getBindGroupLayout(0),
        entries,
      });

      const bindGroupUniform = uniforms && device.createBindGroup({
        layout: pipeline.getBindGroupLayout(1),
        entries: uniforms,
      });

      const loadIntoPass = pass => {
        pass.setPipeline(pipeline);
        pass.setBindGroup(0, bindGroup);
        if (bindGroupUniform) {
          pass.setBindGroup(1, bindGroupUniform);
        }
        pass.dispatchWorkgroups(workGroups);
      };

      return { loadIntoPass, pipeline, bindGroup, bindGroupUniform };
    }

    function createMapping(device, commandEncoder, buffer, out) {
      const ArrayConst = out.constructor
      const bufferSize = out.length * ArrayConst.BYTES_PER_ELEMENT;
      const stagingBuffer = device.createBuffer({
        size: bufferSize,
        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
      });

      commandEncoder.copyBufferToBuffer(
        buffer, 0,
        stagingBuffer, 0,
        bufferSize
      );

      const read = async () => {
        await stagingBuffer.mapAsync(GPUMapMode.READ);
        out.set(new ArrayConst(stagingBuffer.getMappedRange()));
        stagingBuffer.unmap();
      };

      return { read, stagingBuffer };
    }

    /**
     * Setup data for processing
     */
    async function setupData() {
      function loadWideData(cfg) {
        return fetch(cfg.url)
            .then(r => r.text())
            .then(t => csv.processCsv(t, {
              headers: cfg.headers.load,
              dropRows: cfg.dropRows ?? 0,
            }))
            .then(df => {
              const { retain, colout } = cfg.headers.long;
              return csv.wideToLong(df, retain, colout);
            })
            .then(df => csv.filter(df, 'year', y => y >= 2000))
      }

      function loadLongData(cfg) {
        return fetch(cfg.url)
            .then(r => r.text())
            .then(t => csv.processCsv(t, {
              headers: cfg.headers,
              dropRows: cfg.dropRows ?? 0,
            }))
      }

      function loadItuData(cfg) {
        return loadLongData(cfg)
            .then(df => csv.filter(df, 'seriesCode', y => y === cfg.seriesCode))
            .then(df => csv.dropColumn(df, 'seriesCode'))
            .then(df => csv.renameColumn(df, 'value', cfg.dataName))
      }

      const diffF32Array = (arr, groups) => {
        const diff = new Float32Array(arr.length);

        for (const [groupValue, { offset, count }] of groups.groups.entries()) {
          // First value in group stays as-is
          diff[offset] = arr[offset];

          // Compute diffs within this group only
          for (let i = 1; i < count; i++) {
            const idx = offset + i;
            diff[idx] = arr[idx] - arr[idx - 1];
          }
        }

        return diff;
      };

      const [
        ituPhone,
        ituMobileInternet,
        wbPop,
        wbLabourForce,
        wbUnemployment,
        pwtStock,
      ] = await Promise.all([
        loadItuData(datasets.ituCellPhones),
        loadItuData(datasets.ituMobileBoardBandSubcriptions),
        loadWideData(datasets.wbPopulation),
        loadWideData(datasets.wbLabourForce).then(df => {
          return csv.filter(df, 'labourForce', lf => !Number.isNaN(lf));
        }),
        loadWideData(datasets.wbUnemployment).then(df => {
          return csv.filter(df, 'unemployment', lf => !Number.isNaN(lf));
        }),
        loadWideData(datasets.pwtCapitalStock),
      ]);

      const join = csv.innerJoins(
        [ituPhone, ituMobileInternet, wbPop, wbLabourForce, wbUnemployment, pwtStock],
        ['countryIso', 'year'],
      );
      const joinGroup = csv.sortAndIdentifyGroups('countryIso', 'year', join);
      const size = csv.getSize(join);
      console.log(join);

      join.technology = new Float32Array(size);
      join.initialTech = new Float32Array(size);
      join.capitalSteadyState = new Float32Array(size);
      join.capital = new Float32Array(size);
      join.output = new Float32Array(size);
      join.phoneUsageD = diffF32Array(join.phoneUsage, joinGroup);
      join.phoneInternetD = diffF32Array(join.phoneInternet, joinGroup);

      for (let i = 0; i < size; i++) {
        join.initialTech[i] = INITIAL_TECH;
      }

      return [size, joinGroup, join];
    }
  </script>
  <script type="text/wgsl" id="compute-shader">
    struct Effects {
      phoneFixed: f32,
      internetExp: f32,
    };

    struct ExogenousState {
      alpha: f32,
      saving: f32,
      depreciation: f32,
    };

    @group(1) @binding(0) var<uniform> exogenous: ExogenousState;
    @group(1) @binding(1) var<uniform> effects: Effects;

    @group(0) @binding(0) var<storage, read_write> technology: array<f32>;
    @group(0) @binding(1) var<storage, read_write> output: array<f32>;
    @group(0) @binding(2) var<storage, read> phoneAccessGrowth: array<f32>;
    @group(0) @binding(3) var<storage, read> phoneInternetGrowth: array<f32>;
    @group(0) @binding(4) var<storage, read> prevTechnology: array<f32>;
    @group(0) @binding(5) var<storage, read> unemployment: array<f32>;
    @group(0) @binding(6) var<storage, read> labourForce: array<f32>;

    /**
     * Computes technology over the different periods
     */
    @compute @workgroup_size(1)
    fn step1(@builtin(global_invocation_id) global_id: vec3<u32>) {
      let idx = global_id.x;
      let l = labourForce[idx] * (1 - unemployment[idx]);
      technology[idx] = phoneAccessGrowth[idx] * effects.phoneFixed
                      + phoneInternetGrowth[idx] * effects.internetExp
                      + prevTechnology[idx];
      output[idx] = technology[idx] * pow(l, exogenous.alpha);
    }


    @group(0) @binding(0) var<storage, read_write> capitalSteadyState: array<f32>;
    @group(0) @binding(1) var<storage, read> technologyInput: array<f32>;

    @compute @workgroup_size(64)
    fn step2(@builtin(global_invocation_id) global_id: vec3<u32>) {
      let idx = global_id.x;
      let a = exogenous.alpha * technologyInput[idx];
      let l = labourForce[idx] * (1 - unemployment[idx]);
      capitalSteadyState[idx] = exogenous.alpha * technologyInput[idx];


    }
  </script>
</body>
</html>
