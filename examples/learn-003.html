<!DOCTYPE html>
<html lang="en">
<head>
  <base target="_blank">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="application-name" content="TFP Growth Model" lang="en" />
  <meta name="description" content="Compute a TFP growth model based on phone adoption via WebGPU">
  <link rel="stylesheet" href="../common/frame-style.css">
  <title>Web GPU - Line Graph</title>
  <style>
    .container { display: none; }
    body {
      padding: 16px;
    }
    .text-container {
      margin: 0 auto;
      max-width: 550px;
    }
    table {
      margin: 0 auto;
      border-right: 0.5px solid white;
      border-bottom: 0.5px solid white;
      th { background: white; color: black }
      & tr > :is(td,th) {
        padding: 2px 4px;
        border-left: 0.5px solid white;
        border-top: 0.5px solid white;
      }
    }
    * { box-sizing: border-box; color: white }
    p, ul { line-height: 1.5; }
  </style>
</head>
<body>
  <template id="model-syntax">
    <div class="text-container">
      <h1>TFP growth via Phones & Internet</h1>
      <math display="block">
        <mover>
          <mtable>
            <mtr>
              <mtd columnalign="right"><msub><mi>A</mi><mi>t</mi></msub></mtd>
              <mtd><mo>=</mo></mtd>
              <mtd columnalign="left">
                <msub>
                  <mi>A</mi>
                  <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow>
                </msub>
                <mo>+</mo>
                <mrow>
                  <mi>ùõΩ</mi>
                  <mo>¬∑</mo>
                  <msub><mi>ùúë</mi><mi>t</mi></msub>
                </mrow>
                <mo>+</mo>
                <mrow>
                  <mi>ùõæ</mi>
                  <mo>¬∑</mo>
                  <msub><mi>ùúì</mi><mi>t</mi></msub>
                </mrow>
              </mtd>
            </mtr>
            <mtr>
              <mtd columnalign="right"><msub><mi>K</mi><mi>t</mi></msub></mtd>
              <mtd><mo>=</mo></mtd>
              <mtd columnalign="left">
                <mrow>
                  <msub>
                    <mi>K</mi>
                    <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow>
                  </msub>
                  <mo>¬∑</mo>
                  <mrow>
                    <mo>(</mo>
                    <mrow><mn>1</mn><mo>-</mo><mi>d</mi></mrow>
                    <mo>)</mo>
                  </mrow>
                </mrow>
                <mo>+</mo>
                <mrow>
                  <mi>s</mi>
                  <mo>¬∑</mo>
                  <msub><mi>Y</mi><mi>t</mi></msub>
                </mrow>
              </mtd>
            </mtr>
            <mtr>
              <mtd columnalign="right"><msub><mi>Y</mi><mi>t</mi></msub></mtd>
              <mtd><mo>=</mo></mtd>
              <mtd columnalign="left">
                <msub><mi>A</mi><mi>t</mi></msub>
                <mo>¬∑</mo>
                <msubsup>
                  <mi>L</mi>
                  <mi>t</mi>
                  <mi>ùõº</mi>
                </msubsup>
                <mo>¬∑</mo>
                <msubsup>
                  <mi>K</mi>
                  <mi>t</mi>
                  <mrow><mn>1</mn><mo>-</mo><mi>ùõº</mi></mrow>
                </msubsup>
              </mtd>
            </mtr>
          </mtable>
          <mover><mo>‚èû</mo><mtext>TFP with Fixed effects growth</text></mover>
        </mover>
      </math>
      <h2>About</h2>
      <p>
        This model <s>assumes all countries have TFP of 1000 at the start
        (almost certianly incorrect), and this might be to explain for
        the dramatically incorrect results for capital and output</s>,
        may produce weird results when countries are missing enough
        data points for inputs.
      </p>
      <h2>Models</h2>
      <ul>
        <li>
          <b>Version A: ùúë‚Çú and ùúì‚Çú return number connection</b>
          <ul>
            <li>Every device adds the same a fixed amount to the model</li>
          </ul>
          <br>
        </li>
        <li>
          <b>Version B: ùúë‚Çú and ùúì‚Çú return (number connection) / population</b>
          <ul>
            <li>
              The original model actually was supposed to return a number between 0 & 1
              from <b>ùúë‚Çú and ùúì‚Çú</b> to represent the proportion of the population, this
              is something we forgot to do eariler.
            </li>
            <br>
          </ul>
        </li>
        <li>
          <b>Version C: ùúë‚Çú, ùúì‚Çú = 0</b>
          <ul>
            <li>Remove the impact of telecommunication from the model</li>
          </ul>
        </li>
      </ul>
      <h2>Data Sources</h2>
    </div>
    <table>
      <thead>
        <tr>
          <th>Variable</th>
          <th>Source</th>
          <th>About</th>
          <th>Data Cleaning</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>mobilePhoneInternetConnections</td>
          <td><a target="_blank" href="https://datahub.itu.int/dashboards/">ITU</a></td>
          <td>Mobile broadband subscription rate</td>
          <td>Forward-filled missing values</td>
        </tr>
        <tr>
          <td>mobilePhoneSubscription</td>
          <td><a target="_blank" href="https://datahub.itu.int/dashboards/">ITU</a></td>
          <td>Mobile phone subscription rate</td>
          <td>Forward-filled missing values</td>
        </tr>
        <tr>
          <td>capitalPPP</td>
          <td><a target="_blank" href="https://pwt-data-tool.streamlit.app">Penn World Table</a></td>
          <td>Capital stock (PPP adjusted)</td>
          <td>1999 value used for initial capital at start of 2000</td>
        </tr>
        <tr>
          <td>ctfp</td>
          <td><a target="_blank" href="https://pwt-data-tool.streamlit.app">Penn World Table</a></td>
          <td>Total Factor Productivity</td>
          <td>1999 value used; missing values filled with 1999 average (0.636244538850831)</td>
        </tr>
        <tr>
          <td>labourForce</td>
          <td><a target="_blank" href="https://data.worldbank.org/indicator/SL.TLF.TOTL.IN">World Bank</a></td>
          <td>Total labor force</td>
          <td>Forward-filled missing values</td>
        </tr>
        <tr>
          <td>population</td>
          <td><a target="_blank" href="https://data.worldbank.org/indicator/SP.POP.TOTL">World Bank</a></td>
          <td>Total population</td>
          <td>Forward-filled missing values</td>
        </tr>
        <tr>
          <td>unemployment</td>
          <td><a target="_blank" href="https://data.worldbank.org/indicator/SL.UEM.TOTL.ZS">World Bank</a></td>
          <td>Unemployment rate (%)</td>
          <td>Forward-filled missing values</td>
        </tr>
        <tr>
          <td>laboursShare</td>
          <td><a target="_blank" href="https://pwt-data-tool.streamlit.app">Penn World Table</a></td>
          <td>Labor's share of income (Œ±)</td>
          <td>Forward-filled missing values; 2000 values filled with average when missing</td>
        </tr>
        <tr>
          <td>grossSavingsPct</td>
          <td><a target="_blank" href="https://data.worldbank.org/indicator/NY.GNS.ICTR.ZS">World Bank</a></td>
          <td>Gross savings as % of GDP</td>
          <td>Forward-filled missing values; 2000 values filled with average when missing</td>
        </tr>
        <tr>
          <td>avgDepreciation</td>
          <td><a target="_blank" href="https://pwt-data-tool.streamlit.app">Penn World Table</a></td>
          <td>Average depreciation rate (Œ¥)</td>
          <td>Forward-filled missing values; 2000 values filled with average when missing</td>
        </tr>
      </tbody>
      <caption>
        <p>Input Variables</p>
      </caption>
    </table>
    <table>
      <thead>
        <tr>
          <th>Variable</th>
          <th>About</th>
          <th>Data Cleaning</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>employed</td>
          <td>LF √ó (1 - unemployment/100)</td>
          <td>‚Äî</td>
        </tr>
        <tr>
          <td>out_output_{a,b,c}</td>
          <td>Output (Y) from Cobb-Douglas production function</td>
          <td>‚Äî</td>
        </tr>
        <tr>
          <td>out_capital_{a,b,c}</td>
          <td>Capital stock (K) from accumulation equation</td>
          <td>‚Äî</td>
        </tr>
        <tr>
          <td>out_capitalSteadyState_{a,b,c}</td>
          <td>Steady-state capital given current technology and labor</td>
          <td>‚Äî</td>
        </tr>
        <tr>
          <td>out_technology_{a,b,c}</td>
          <td>Total Factor Productivity (A) with phone/internet effects</td>
          <td>‚Äî</td>
        </tr>
        <tr>
          <td>faked_askAngusWhatThatMeans</td>
          <td>Flags which observations had missing data</td>
          <td>Forward-filled from previous period; first period missing = 0</td>
        </tr>
      </tbody>
      <caption>
        <p>Output Variables</p>
      </caption>
    </table>
  </template>
  <script>
    window.addEventListener('error', event => console.error(event.error));
    window.addEventListener('unhandledrejection', event => console.error(event.error));

    if (window.parent == null) alert('note this page was designed to run in an iframe');
  </script>
  <script type="module">
    import * as csv from '../common/data/csv.js';
    import * as datasets from '../common/data/datasets.js';
    import { initWebGPU } from '../common/webgpu/init.js';
    import { createBuffer, createStep, createMapping, initStructArrayBuffer, extractStructArrays } from '../common/webgpu/setup.js';
    import { UniformAdapter } from '../common/webgpu/uniforms.js';

    document.body.insertBefore(
      document.getElementById('model-syntax').content.cloneNode(true),
      document.body.firstChild,
    );

    const INIT_LEGACY = 0.00000001
    const INIT_COEFF_PHONE = 0.1;
    const INIT_COEFF_INTERNET = 0.1;

    {
      window.addEventListener('message', onMessage);
      window.parent?.postMessage({
        kind: 'register-button',
        label: 'Download Inputs',
        id: 'download-inputs',
      });

      window.parent?.postMessage({
        kind: 'register-button',
        label: 'Download All',
        id: 'download-out',
      });

      window.parent?.postMessage({
        kind: 'register-button',
        label: 'Download Initial Values',
        id: 'download-inital-values',
      });

      window.parent?.postMessage({
        kind: 'register-knobs',
        knobs: [
          { kind: 'boolean', name: 'useFixedParams', label: 'Fixed (ùõº, s, d)', init: false },
          { kind: 'title', title: 'Exogenous Variables' },
          { kind: 'number', name: 'alpha', label: '(ùõº) Alpha', init: 2/3 },
          { kind: 'number', name: 'saving', label: '(sÃÑ) Savings Rate', init: 0.4 },
          { kind: 'number', name: 'depreciation', label: '(dÃÑ) Deprecation Rate', init: 0.07 },
          { kind: 'divider' },
          { kind: 'title', title: 'Fixed Effects' },
          { kind: 'number', name: 'phoneEffect_pc', label: 'ùõΩ Phone Effect (f(ùõΩ) = ùõΩùúë‚Çú)', init: INIT_COEFF_PHONE },
          { kind: 'number', name: 'phoneInternet_pc', label: 'ùõæ Internet Effect (f(ùõæ) = ùõæùúì‚Çú)', init: INIT_COEFF_INTERNET },
          { kind: 'divider' },
          { kind: 'title', title: 'Fixed Effects (legacy)' },
          { kind: 'number', name: 'phoneEffect', label: 'ùõΩ Phone Effect (f(ùõΩ) = ùõΩùúë‚Çú)', init: INIT_LEGACY },
          { kind: 'number', name: 'phoneInternet', label: 'ùõæ Internet Effect (f(ùõæ) = ùõæùúì‚Çú)', init: INIT_LEGACY },
        ],
      });
    }

    const { canvas, adpater, device } = await initWebGPU();

    const [size, groups, df, inits] = await setupData().catch(e => {
      console.error(e);
      throw e
    });
    showLog('Observations:', csv.getSize(df));
    showLog('Countries:', groups.groupValues.length);
    showLog('Nation Offsets', [...inits.offsets]);

    const uniformCfg = UniformAdapter.create([
      { type: 'u32', size: 4, init: 25, name: 'year_per_country' },
      { type: 'u32', size: 4, init: size, name: 'observations' },
      { type: 'u32', size: 4, init: csv.getSize(inits), name: 'countries' },
      { type: 'u32', size: 4, init: 10, name: 'ralph_newton_iterations' },
      { type: 'u32', size: 4, init: 0, name: 'use_fixed_params' },
    ]);

    const uniformExo = UniformAdapter.create([
      { type: 'f32', size: 4, init: 2/3, name: 'alpha' },
      { type: 'f32', size: 4, init: 0.4, name: 'saving' },
      { type: 'f32', size: 4, init: 0.07, name: 'depreciation' },
    ]);

    const uniformEff = UniformAdapter.create([
      { type: 'f32', size: 4, init: INIT_COEFF_PHONE, name: 'phoneEffect_pc' },
      { type: 'f32', size: 4, init: INIT_COEFF_INTERNET, name: 'phoneInternet_pc' },
      { type: 'f32', size: 4, init: INIT_LEGACY, name: 'phoneEffect' },
      { type: 'f32', size: 4, init: INIT_LEGACY, name: 'phoneInternet' },
    ]);

    device.pushErrorScope('validation');

    const { COPY_DST, COPY_SRC } = GPUBufferUsage;
    const bufferCountryConfig = initStructArrayBuffer(device, [
      inits.offsets,
      inits.capital,
      inits.technology,
    ], COPY_DST);

    // Combined output buffer: 12 contiguous fields
    const combinedOutputData = new Float32Array(new Array(size * 12).fill(0));
    const bufferCombinedOutput = createBuffer(device, combinedOutputData, COPY_SRC | COPY_DST);

    const bufferAuxiliaryTimeSeries = initStructArrayBuffer(device, [
      df.unemployment,
      df.labourForce,
      df.mobilePhoneSubscription,
      df.mobilePhoneInternetConnections,
      df.population,
    ], COPY_DST);

    const bufferPrimaryTimeSeries = initStructArrayBuffer(device, [
      df.laboursShare,
      df.grossSavingsPct,
      df.avgDepreciation,
    ], COPY_DST);

    const bufferUnifExo = uniformExo.createBuffer(device);
    const bufferUnifEff = uniformEff.createBuffer(device);
    const bufferUnifCfg = uniformCfg.createBuffer(device);

    const shaderCode = document.getElementById('compute-shader').textContent;
    const shaderModule = device.createShaderModule({ code: shaderCode });

    const step1 = createStep({
      device,
      shaderModule,
      uniforms: [
        { binding: 1, resource: { buffer: bufferUnifEff } },
        { binding: 2, resource: { buffer: bufferUnifCfg } },
      ],
      workGroups: Math.ceil(size / 64),
      entryPoint: 'step1',
      entries: [
        { binding: 0, resource: { buffer: bufferCountryConfig } },
        { binding: 10, resource: { buffer: bufferCombinedOutput } },
        { binding: 20, resource: { buffer: bufferAuxiliaryTimeSeries } },
      ],
    });

    const step2 = createStep({
      device,
      shaderModule,
      uniforms: [
        { binding: 0, resource: { buffer: bufferUnifExo } },
        { binding: 1, resource: { buffer: bufferUnifEff } },
        { binding: 2, resource: { buffer: bufferUnifCfg } },
      ],
      workGroups: [csv.getSize(inits), 3, 1],
      entryPoint: 'step2',
      entries: [
        { binding: 0, resource: { buffer: bufferCountryConfig } },
        { binding: 10, resource: { buffer: bufferCombinedOutput } },
        { binding: 20, resource: { buffer: bufferAuxiliaryTimeSeries } },
        { binding: 30, resource: { buffer: bufferPrimaryTimeSeries } },
      ],
    });

    const step3 = createStep({
      device,
      shaderModule,
      uniforms: [
        { binding: 0, resource: { buffer: bufferUnifExo } },
        { binding: 2, resource: { buffer: bufferUnifCfg } },
      ],
      workGroups: [Math.ceil(size / 64), 3, 1],
      entryPoint: 'step3',
      entries: [
        { binding: 0, resource: { buffer: bufferCountryConfig } },
        { binding: 10, resource: { buffer: bufferCombinedOutput } },
        { binding: 30, resource: { buffer: bufferPrimaryTimeSeries } },
      ],
    });

    showLog('running GPU');
    await runGPU();
    console.log(df);

    const errorScope = await device.popErrorScope();
    if (errorScope) {
      console.error('GPU:',errorScope.message);
      showLog('error', errorScope.message);
      console.info(errorScope);
    } else {
      showLog('done');
    }

    async function runGPU() {
      try {
        const commandEncoder = device.createCommandEncoder();
        const pass = commandEncoder.beginComputePass();
        step1.loadIntoPass(pass);
        step2.loadIntoPass(pass);
        step3.loadIntoPass(pass);
        pass.end();

        const mapping = createMapping(
          device,
          commandEncoder,
          bufferCombinedOutput,
          combinedOutputData,
        );

        device.queue.submit([commandEncoder.finish()]);
        await mapping.read();

        extractStructArrays(combinedOutputData, [
          df.employed,
          df.out_a_capital,
          df.out_a_capitalSteadyState,
          df.out_a_output,
          df.out_a_technology,
          df.out_b_capital,
          df.out_b_capitalSteadyState,
          df.out_b_output,
          df.out_b_technology,
          df.out_c_capital,
          df.out_c_capitalSteadyState,
          df.out_c_output,
        ]);


        showLog('Employed results:', [...df.employed.slice(0, 10)]);
        showLog('(C) Output:', [...df.out_c_output.slice(0, 10)]);
        showLog('(B) Output:', [...df.out_b_output.slice(0, 10)]);
        showLog('(A) Output:', [...df.out_a_output.slice(0, 10)]);
        showLog('(B) Technology:', [...df.out_b_technology.slice(0, 10)]);
        showLog('(A) Technology:', [...df.out_a_technology.slice(0, 10)]);
        showLog('(C) Captial:', [...df.out_c_capital.slice(0, 10)]);
        showLog('(B) Captial:', [...df.out_b_capital.slice(0, 10)]);
        showLog('(A) Captial:', [...df.out_a_capital.slice(0, 10)]);
        showLog('(C) Capital ss:', [...df.out_c_capitalSteadyState.slice(0, 10)]);
        showLog('(B) Capital ss:', [...df.out_b_capitalSteadyState.slice(0, 10)]);
        showLog('(A) Capital ss:', [...df.out_a_capitalSteadyState.slice(0, 10)]);
        console.info(df, groups);
      } catch (e) {
        console.error(e);
      }
    }

    async function onMessage(event) {
      try {
        const message = event.data;
        switch (message.kind) {
          case 'action':
            return await onAction(message);

          case 'update-knobs':
            return updateUniforms(message.data)

          default:
            return console.log('unknown message', message);
        }
      } catch (e) {
        console.error(e);
      }
    }

    async function updateUniforms(data) {
      console.log(data);
      uniformExo.update('alpha', data.alpha);
      uniformExo.update('saving', data.saving);
      uniformExo.update('depreciation', data.depreciation);
      uniformEff.update('phoneEffect', data.phoneEffect);
      uniformEff.update('phoneInternet', data.phoneInternet);
      uniformEff.update('phoneEffect_pc', data.phoneEffect_pc);
      uniformEff.update('phoneInternet_pc', data.phoneInternet_pc);
      uniformCfg.update('use_fixed_params', data.useFixedParams ? 1 : 0);
      uniformExo.updateBuffer(device, bufferUnifExo);
      uniformEff.updateBuffer(device, bufferUnifEff);
      uniformCfg.updateBuffer(device, bufferUnifCfg);
      await runGPU();
      showLog('done');
    }

    async function onAction(message) {
      switch (message.id) {
        case 'download-inputs':
          return await csv.downloadFile(
            csv.renameColumn(
              csv.dropColumn(df, [
                'countryId',
                'computed_technology',
                'computed_capitalSteadyState',
                'computed_capital',
                'computed_output',
              ]),
              {
                generatedData: 'faked_askAngusWhatThatMeans',
              },
            ),
            'model-inputs.csv',
          );

        case 'download-out':
          return await csv.downloadFile(
            csv.renameColumn(
              csv.dropColumn(df, [
                'countryId',
              ]),
              {
                generatedData: 'faked_askAngusWhatThatMeans',
              },
            ),
            'all-model-data-points.csv',
          );

        case 'download-inital-values':
          return await csv.downloadFile(
            csv.renameColumn(inits, {
              technology: 'ctfp_1999_or_avg',
              capital: 'capital_1999',
            }),
            'country-initialisation-values.csv',
          );

        default:
          return console.log('unknown action', message);
      }
    }

    function showLog(...args) {
      window.parent?.postMessage({ kind: 'push-log', log: args });
    }

    /**
     * Setup data for processing
     */
    async function setupData() {
      const fetching = {
        loadWideData(cfg) {
          return fetch(cfg.url)
              .then(r => r.text())
              .then(t => csv.processCsv(t, {
                headers: cfg.headers.load,
                dropRows: cfg.dropRows ?? 0,
              }))
              .then(df => {
                const { retain, colout } = cfg.headers.long;
                return csv.wideToLong(df, retain, colout);
              })
        },
        loadLongData(cfg) {
          return fetch(cfg.url)
              .then(r => r.text())
              .then(t => csv.processCsv(t, {
                headers: cfg.headers,
                dropRows: cfg.dropRows ?? 0,
              }))
        },
        loadItuData(cfg) {
          return fetching.loadLongData(cfg)
              .then(df => csv.filter(df, 'seriesCode', y => y === cfg.seriesCode))
              .then(df => csv.dropColumn(df, 'seriesCode'))
              .then(df => csv.renameColumn(df, { value: cfg.dataName }))
        },
      };

      const columnsThatNeedCleaning = [
        'capitalPPP', 'labourForce', 'mobilePhoneInternetConnections',
        'mobilePhoneSubscription', 'population', 'unemployment', 'ctfp',
      ];
      const columnsWeCanFake = [
        'grossSavingsPct',
        'avgDepreciation',
        'laboursShare',
      ];
      const badData = [
        'ARM', 'BDI', 'CIV',
        'GIN', 'LBN', 'SDN',
        'SRB', 'ZWE', 'QAT',
        'SAU', 'VEN',
      ];
      const columnsThatNeedRepeating = ['countryId', 'countryIso', 'countryName'];


      const [
        ituPhone,
        ituMobileInternet,
        wbPop,
        wbLabourForce,
        wbUnemployment,
        wbSavings,
        pwtStock,
        pwtTfpStock,
        pwtAvgDepreciation,
        pwtLabourShare,
      ] = await Promise.all([
        fetching.loadItuData(datasets.ituCellPhones),
        fetching.loadItuData(datasets.ituMobileBoardBandSubcriptions),
        fetching.loadWideData(datasets.wbPopulation),
        fetching.loadWideData(datasets.wbLabourForce),
        fetching.loadWideData(datasets.wbUnemployment),
        fetching.loadWideData(datasets.wbSavingsRateOfGDP),
        fetching.loadWideData(datasets.pwtCapitalStock),
        fetching.loadWideData(datasets.pwtTfpStock),
        fetching.loadWideData(datasets.pwtAvgDepreciation),
        fetching.loadWideData(datasets.pwtLabourShare),
      ]);

      // insert any safe values if there's risk of data being dropped.
      const countryIsos = [...(new Set(wbPop.countryIso.concat(pwtStock.countryIso)))].sort();

      let join = csv.outerJoins(
        [
          ituPhone, ituMobileInternet, wbPop, wbLabourForce,
          wbUnemployment, pwtStock, pwtTfpStock,
          wbSavings, pwtAvgDepreciation, pwtLabourShare,
        ],
        ['countryIso', 'year'],
      );
      join = csv.filter(join, 'year', year => !Number.isNaN(year) && year > 1999);
      let joinGroup = csv.sortAndIdentifyGroups('countryIso', 'year', join);
      join = joinGroup.frame;

      for (const [col, ds] of [
        ['grossSavingsPct', datasets.wbSavingsRateOfGDP],
        ['avgDepreciation', datasets.pwtAvgDepreciation],
        ['laboursShare', datasets.pwtLabourShare],
      ]) {
        for (const country of countryIsos) {
          const index = csv.findIndex(join, [
            ['year', year => year === 2000],
            ['countryIso', iso => iso === country],
          ]);

          if (index == null) continue;
          const value = join[col][index];
          const weird = (value == null || Number.isNaN(value) || value == 0);
          if (weird) {
            join[col][index] = ds.avg2000;
          }
        }
      }

      joinGroup = csv.filterGroups(joinGroup, { uniformSize: true }, meta => {
        if (meta.max < 2012 || meta.count < 10) return false;


        const join = joinGroup.frame;
        const { count, offset } = meta;

        for (const colname of columnsThatNeedCleaning) {
          if (colname === 'ctfp') continue;
          const input = join[colname];
          let nans = 0;
          for (let i = 0; i < count; i++) {
            if (Number.isNaN(input[offset + i])) nans += 1;
          }
          if (nans >= (count - nans)) return false;
        }

        return true;
      });


      joinGroup = csv.sortAndIdentifyGroups('countryIso', 'year', joinGroup.frame);
      join = joinGroup.frame;

      const size = csv.getSize(join);
      join.employed = new Float32Array(size);
      join.out_a_technology = new Float32Array(size);
      join.out_a_capitalSteadyState = new Float32Array(size);
      join.out_a_capital = new Float32Array(size);
      join.out_a_output = new Float32Array(size);
      join.out_b_technology = new Float32Array(size);
      join.out_b_capitalSteadyState = new Float32Array(size);
      join.out_b_capital = new Float32Array(size);
      join.out_b_output = new Float32Array(size);
      join.out_c_capitalSteadyState = new Float32Array(size);
      join.out_c_capital = new Float32Array(size);
      join.out_c_output = new Float32Array(size);

      join.generatedData = new Array(size).fill('');


      /**
       * Clean up the data may not be complete
       */
      for (const colname of [
        ...columnsThatNeedCleaning,
        ...columnsWeCanFake,
      ]) {
        const input = join[colname];
        for (const [groupValue, { offset, count }] of joinGroup.groups.entries()) {
          if (Number.isNaN(input[offset])) {
            input[offset] = 0;
            join.generatedData[offset] += ':'+colname
          }
          for (let i = 1; i < count; i++) {
            let idx = offset + i;
            if (Number.isNaN(input[idx])) {
              join.generatedData[idx] += ':'+colname
              input[idx] = input[idx-1];
              if (Number.isNaN(input[idx])) debugger;
            }
          }
        }
      }

      const initCapital = Array.from(joinGroup.groups.keys(), country => {
        const index = csv.findIndex(pwtStock, [
          ['year', year => year === 1999],
          ['countryIso', iso => iso === country],
        ]);
        return pwtStock.capitalPPP[index];
      });

      const initTFP = Array.from(joinGroup.groups.keys(), country => {
        const index = csv.findIndex(pwtTfpStock, [
          ['year', year => year === 1999],
          ['countryIso', iso => iso === country],
        ]);
        const value = pwtTfpStock.ctfp[index];
        const weird = (value == null || Number.isNaN(value) || value == 0);
        return weird ? (datasets.pwtTfpStock.avg1999 / 2) : value;
      });

      for (let i = 0; i < size; i++) join.grossSavingsPct[i] = join.grossSavingsPct[i] / 100;

      const offsets = Array.from(joinGroup.groups.values(), row => row.offset);

      const initalValues = csv.createDf({
        countryIso: Array.from(joinGroup.groups.keys()),
        capital: new Float32Array(initCapital),
        technology: new Float32Array(initTFP),
        offsets: new Uint32Array(offsets),
      });
      return [size, joinGroup, join, initalValues];
    }
  </script>
  <script type="text/wgsl" id="compute-shader">
    struct Config {
      year_per_country: u32,
      observations: u32,
      countries: u32,
      ralph_newton_iterations: u32,
      use_fixed_params: u32,
    };

    struct Effects {
      phone_fixed_pc: f32,
      net_exp_pc: f32,
      phone_fixed: f32,
      net_exp: f32,
    };

    struct ModelOutput {
      capital: f32,
      capital_ss: f32,
      output: f32,
    }

    struct EndogenousTechModelOutput {
      main: ModelOutput,
      technology: f32,
    }

    struct ComputedState {
      employed: f32,
      ma: EndogenousTechModelOutput,
      mb: EndogenousTechModelOutput,
      mc: ModelOutput,
    }

    struct CountryConfig {
      idx_offset: u32,
      init_capital: f32,
      init_technology: f32,
    }

    struct PrimaryTimeSeries {
      alpha: f32,
      saving: f32,
      depreciation: f32,
    }

    struct AuxiliaryTimeSeries {
      unemployment: f32,
      labour_force: f32,
      mobile_phone_subscription: f32,
      mobile_phone_internet_connections: f32,
      population: f32,
    }

    @group(1) @binding(0) var<uniform> exo: PrimaryTimeSeries;
    @group(1) @binding(1) var<uniform> effects: Effects;
    @group(1) @binding(2) var<uniform> config: Config;

    @group(0) @binding(0) var<storage, read> country_config: array<CountryConfig>;
    @group(0) @binding(10) var<storage, read_write> out: array<ComputedState>;
    @group(0) @binding(20) var<storage, read> aux: array<AuxiliaryTimeSeries>;
    @group(0) @binding(30) var<storage, read> primary: array<PrimaryTimeSeries>;

    /**
     * Uses ralph newton to solve for capital
     * https://en.wikipedia.org/wiki/Newton%27s_method
     *
     * - Basically inline Y into K, creating a simulatenous equation
     * - Move everything on to one side where the other side is zero
     * - Turn the left hand side into a function that takes K as param
     * - Then get a derivative by deriving it by K
     *
     * Knowing this we can brute force different values of K until
     * we get a function that produces zero or a sufficently small
     * number that we are're satisified.
     */
    fn ralph_newton_capital(p: PrimaryTimeSeries, k_last: f32, tech: f32, labour: f32) -> f32 {
      var k_init = k_last;
      if (k_last < 0 || k_last != k_last) { k_init = 1.0; }
      if (tech <= 0 || labour <= 0) { return k_init; }

      let scale = max(k_init, 1.0);
      let base_term = 1.0 - p.depreciation;
      let coeff = p.saving * tech * pow(labour, p.alpha) * pow(scale, -p.alpha);
      var k_scaled = 1.0;

      for (var i = 0u; i < config.ralph_newton_iterations; i++) {
        let k_pow_beta = pow(k_scaled, 1.0 - p.alpha);
        let k_pow_neg_alpha = pow(k_scaled, -p.alpha);
        let f = k_scaled - coeff * k_pow_beta - base_term;
        let f_prime = 1.0 - coeff * (1.0 - p.alpha) * k_pow_neg_alpha;

        // If derivative is negative or too small, the Newton step is unreliable
        // In this case, use a fixed point iteration step instead
        var k_new: f32;

        if (f_prime < 0.1) {
          // Fixed point: k_new = coeff * k^(1-Œ±) + base_term
          k_new = coeff * k_pow_beta + base_term;
        } else {
          // Newton-Raphson step with adaptive damping
          let step = f / f_prime;
          let damping = select(0.7, 0.5, f_prime < 0.5);
          k_new = k_scaled - damping * step;
        }

        let k_safe = max(k_new, 0.5);
        if (abs(k_safe - k_scaled) < 1e-6 * max(abs(k_scaled), 1.0)) {
         return k_safe * scale;
        }
        k_scaled = k_safe;
      }

      return k_scaled * scale;
    }

    /**
     * Computes the steady state at `t` for
     *
     * K(t) = Labour * ((saving*technology)/depreciation)^(1/alpha)
     */
    fn capital_steady_state_at(p: PrimaryTimeSeries, employed: f32, technology: f32) -> f32 {
      let numer = p.saving * technology;
      let denom = p.depreciation;
      return employed * pow(numer/denom, 1.0/p.alpha);
    }

    /**
     * Compute Output, Capital at period t with pre-computed technology.
     */
    fn compute_ykt_at(
      p: PrimaryTimeSeries,
      l: f32,
      a: f32,
      last_capital: f32,
    ) -> vec2<f32> {
      let k = ralph_newton_capital(p, last_capital, a, l);
      let y = a * pow(l, p.alpha) * pow(k, 1 - p.alpha);
      return vec2(y, k);
    }

    /**
     * Pre-compute linear outputs
     */
    @compute @workgroup_size(64)
    fn step1(@builtin(global_invocation_id) global_id: vec3<u32>) {
      let idx = global_id.x;
      if (idx >= config.observations) { return; }

      let aux = aux[idx];
      out[idx].employed = aux.labour_force * (100.0 - aux.unemployment) * (1.0/100.0);

      let country_idx = idx / config.year_per_country;
      let init_tech = country_config[country_idx].init_technology;

      let cellphone_eff = effects.phone_fixed * aux.mobile_phone_subscription;
      let internet_eff = effects.net_exp * aux.mobile_phone_internet_connections;
      out[idx].ma.technology = init_tech + cellphone_eff + internet_eff;

      let cellphone_eff_pc = effects.phone_fixed_pc * (aux.mobile_phone_subscription / aux.population);
      let internet_eff_pc = effects.net_exp_pc * (aux.mobile_phone_internet_connections / aux.population);
      out[idx].mb.technology = init_tech + cellphone_eff_pc + internet_eff_pc;
    }

    /**
     * Computes output and capital for all models in parallel
     */
    @compute @workgroup_size(1, 1, 1)
    fn step2(@builtin(global_invocation_id) global_id: vec3<u32>) {
      let country_idx = global_id.x;
      let model_idx = global_id.y;

      if (country_idx >= config.countries) { return; }
      if (model_idx >= 3u) { return; }

      let offset: u32 = country_config[country_idx].idx_offset;
      var last_k: f32 = country_config[country_idx].init_capital;

      for (var i = 0u; i < config.year_per_country; i++) {
        let idx = offset + i;
        let l = out[idx].employed;

        var a: f32;
        if (model_idx == 0u) {
          a = out[idx].ma.technology;
        } else if (model_idx == 1u) {
          a = out[idx].mb.technology;
        } else {
          a = country_config[country_idx].init_technology;
        }

        var yk: vec2<f32>;
        if (config.use_fixed_params == 1u) {
          yk = compute_ykt_at(exo, l, a, last_k);
        } else {
          yk = compute_ykt_at(primary[idx], l, a, last_k);
        }

        last_k = yk.y;

        if (model_idx == 0u) {
          out[idx].ma.main.output = yk.x;
          out[idx].ma.main.capital = yk.y;
        } else if (model_idx == 1u) {
          out[idx].mb.main.output = yk.x;
          out[idx].mb.main.capital = yk.y;
        } else {
          out[idx].mc.output = yk.x;
          out[idx].mc.capital = yk.y;
        }
      }
    }

    @compute @workgroup_size(64, 1, 1)
    fn step3(@builtin(global_invocation_id) global_id: vec3<u32>) {
      let idx = global_id.x;
      let mid = global_id.y;
      if (idx >= config.observations) { return; }
      if (mid >= 3) { return; }

      var time_series: PrimaryTimeSeries;
      if (config.use_fixed_params == 1u) {
        time_series = exo;
      } else {
        time_series = primary[idx];
      }

      let l = out[idx].employed;
      if (mid == 0u) {
        let a = out[idx].ma.technology;
        out[idx].ma.main.capital_ss = capital_steady_state_at(time_series, l, a);
      } else if (mid == 1u) {
        let a = out[idx].mb.technology;
        out[idx].mb.main.capital_ss = capital_steady_state_at(time_series, l, a);
      } else {
        let a = country_config[idx / config.year_per_country].init_technology;
        out[idx].mc.capital_ss = capital_steady_state_at(time_series, l, a);
      }
    }
  </script>
</body>
</html>
