<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="../common/frame-style.css">
  <title>Web GPU - Line Graph</title>
</head>
<body>
  <script type="module">
    import * as csv from '../common/data/csv.js';
    import { wbPopulation, ituCellPhones } from '../common/data/datasets.js';
    import { initWebGPU } from '../common/init.js';

    const UNIFORM_INIT = {
      alpha: 2/3,
      saving: 0.4,
      depreciation: 0.07,
    };

    try {
      const [size, groups, df] = await setupData();
      const { canvas, adapter, device } = await initWebGPU();

      const bufferSize = size * Float32Array.BYTES_PER_ELEMENT;
      const phoneUsageBuffer = createBuffer(device, df.phoneUsage);
      const prevTechnologyBuffer = createBuffer(device, df.initialTech);
      const technologyBuffer = createBuffer(device, df.technology);
      const capitalSteadyStateBuffer = createBuffer(device, df.capitalSteadyState);

      const shaderCode = document.getElementById('compute-shader').textContent;
      const shaderModule = device.createShaderModule({ code: shaderCode });
      const commandEncoder = device.createCommandEncoder();

      const step1 = createStep({
        device,
        shaderModule,
        commandEncoder,
        bindGroup: 0,
        workGroups: size,
        entryPoint: 'step1',
        entries: [
          { binding: 0, resource: { buffer: phoneUsageBuffer } },
          { binding: 1, resource: { buffer: prevTechnologyBuffer } },
          { binding: 2, resource: { buffer: technologyBuffer } },
        ],
      });

      const step2 = createStep({
        device,
        shaderModule,
        commandEncoder,
        bindGroup: 1,
        workGroups: Math.ceil(size / 64),
        entryPoint: 'step2',
        entries: [
          { binding: 0, resource: { buffer: technologyBuffer } },
          { binding: 1, resource: { buffer: capitalSteadyStateBuffer } },
        ],
      });

      const pass = commandEncoder.beginComputePass();
      step1.load(pass);
      step2.load(pass);

      const stagingBuffer = device.createBuffer({
        size: bufferSize,
        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,
      });

      commandEncoder.copyBufferToBuffer(
        technologyBuffer, 0,
        stagingBuffer, 0,
        bufferSize
      );

      device.queue.submit([commandEncoder.finish()]);
      await stagingBuffer.mapAsync(GPUMapMode.READ);
      df.technology.set(new Float32Array(stagingBuffer.getMappedRange()));
      stagingBuffer.unmap();

      // Read back capitalSteadyState results
      const commandEncoder2 = device.createCommandEncoder();
      commandEncoder2.copyBufferToBuffer(
        capitalSteadyStateBuffer, 0,
        stagingBuffer, 0,
        bufferSize
      );
      device.queue.submit([commandEncoder2.finish()]);

      await stagingBuffer.mapAsync(GPUMapMode.READ);
      df.capitalSteadyState.set(new Float32Array(stagingBuffer.getMappedRange()));
      stagingBuffer.unmap();

      console.log('Ordered and grouped data:', groups, df);
      console.log('Technology results:', df.technology.slice(0, 10));
      console.log('Capital steady state results:', df.capitalSteadyState.slice(0, 10));
    } catch (e) {
      console.error(e);
    }

    function createBuffer(device, data) {
      const buffer = device.createBuffer({
        size: data.length * data.constructor.BYTES_PER_ELEMENT,
        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,
      });
      device.queue.writeBuffer(buffer, 0, data);
      return buffer;
    }

    function createStep({
      device,
      shaderModule,
      entryPoint,
      entries,
      bindGroup: bindGroupId,
      workGroups,
    }) {
      const pipeline = device.createComputePipeline({
        layout: 'auto',
        compute: {
          module: shaderModule,
          entryPoint,
        },
      });

      const bindGroup = device.createBindGroup({
        layout: pipeline.getBindGroupLayout(bindGroupId),
        entries,
      });

      const load = pass => {
        pass.setPipeline(pipeline);
        pass.setBindGroup(bindGroupId, bindGroup);
        pass.dispatchWorkgroups(workGroups);
        pass.end();
      };

      return { load, pipeline, pipeline, bindGroupId };
    }

    /**
     * Setup data for processing
     */
    async function setupData() {
      const [
        wbPop,
        ituPhone,
      ] = await Promise.all([
        (
          fetch(wbPopulation.url)
            .then(r => r.text())
            .then(t => csv.processCsv(t, {
              headers: wbPopulation.headers.load,
              dropRows: wbPopulation.dropRows,
            }))
        ),
        (
          fetch(ituCellPhones.url)
            .then(r => r.text())
            .then(t => csv.processCsv(t, {
              headers: ituCellPhones.headers
            }))
        ),
      ]);

      const size = ituPhone.size;

      csv.renameColumn(ituPhone.df, 'value', 'phoneUsage');
      ituPhone.groups = csv.sortAndIdentifyGroups('countryId', 'year', ituPhone.df);

      // Exogenous, will populate later
      ituPhone.df.labour = new Float64Array(size);

      // Computed in first step
      ituPhone.df.technology = new Float64Array(size);
      ituPhone.df.initialTech = new Float64Array(size);

      // Computed in second step
      ituPhone.df.capitalSteadyState = new Float64Array(size);

      // Computed in third step
      ituPhone.df.capital = new Float64Array(size);
      ituPhone.df.output = new Float64Array(size);

      for (let i = 0; i < size; i++) {
        ituPhone.df.labour[i] = 1;
        ituPhone.df.initialTech[i] = 1_000_000;
      }

      return [size, ituPhone.groups, ituPhone.df];
    }
  </script>
  <script type="text/wgsl" id="compute-shader">
    @group(0) @binding(0) var<storage, read> phoneUsage: array<f32>;
    @group(0) @binding(1) var<storage, read> prevTechnology: array<f32>;
    @group(0) @binding(2) var<storage, read_write> technology: array<f32>;

    @compute @workgroup_size(1)
    fn step1(@builtin(global_invocation_id) global_id: vec3<u32>) {
      let idx = global_id.x;
      technology[idx] = 1.0 + phoneUsage[idx] * prevTechnology[idx];
    }


    @group(1) @binding(0) var<storage, read> technologyInput: array<f32>;
    @group(1) @binding(1) var<storage, read_write> capitalSteadyState: array<f32>;

    @compute @workgroup_size(64)
    fn step2(@builtin(global_invocation_id) global_id: vec3<u32>) {
      let idx = global_id.x;
      capitalSteadyState[idx] = technologyInput[idx];
    }
  </script>
</body>
</html>
