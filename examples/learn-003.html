<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="application-name" content="TFP Growth Model" lang="en" />
  <meta name="description" content="Compute a TFP growth model based on phone adoption via WebGPU">
  <link rel="stylesheet" href="../common/frame-style.css">
  <title>Web GPU - Line Graph</title>
  <style>
    .container { display: none; }
    body {
      padding: 16px;
      margin: 0 auto;
      max-width: 550px;
    }
    * { box-sizing: border-box; color: white }
  </style>
</head>
<body>
  <script>
    window.addEventListener('error', event => console.error(event.error));
    window.addEventListener('unhandledrejection', event => console.error(event.error));

    if (window.parent == null) alert('note this page was designed to run in an iframe');
  </script>
  <script type="module">
    import * as csv from '../common/data/csv.js';
    import * as datasets from '../common/data/datasets.js';
    import { initWebGPU } from '../common/webgpu/init.js';
    import { createBuffer, createStep, createMapping } from '../common/webgpu/setup.js';
    import { UniformAdapter } from '../common/webgpu/uniforms.js';

    const wait = t => (new Promise(r => setTimeout(() => r(), t)))
    await wait(0);

    document.body.insertBefore(
      document.getElementById('model-syntax').content.cloneNode(true),
      document.body.firstChild,
    );


    const INITIAL_TECH = 1_000;

    window.addEventListener('message', onMessage);
    window.parent?.postMessage({
      kind: 'register-button',
      label: 'Download Inputs',
      id: 'download-inputs',
    });

    window.parent?.postMessage({
      kind: 'register-button',
      label: 'Download All',
      id: 'download-all',
    });

    window.parent?.postMessage({
      kind: 'register-knobs',
      knobs: [
        { kind: 'title', title: 'Exogenous Variables' },
        { kind: 'number', name: 'alpha', label: '(ùõº) Alpha', init: 2/3 },
        { kind: 'number', name: 'saving', label: '(sÃÑ) Savings Rate', init: 0.4 },
        { kind: 'number', name: 'depreciation', label: '(dÃÑ) Deprecation Rate', init: 0.07 },
        { kind: 'number', name: 'technology', label: '(A‚ÇÄ) (TFP Init)', init: 1000 },
        { kind: 'title', title: 'Fixed Effects' },
        { kind: 'number', name: 'phoneEffect', label: 'ùõΩ Phone Effect (f(ùõΩ) = ùõΩùúë‚Çú)', init: 0.001 },
        { kind: 'number', name: 'phoneInternet', label: 'ùõæ Internet Effect (f(ùõæ) = ùõæùúì‚Çú)', init: 0.001 },
      ],
    });

    const { canvas, adpater, device } = await initWebGPU();
    const [size, groups, df, inits] = await setupData();
    showLog('Observations:', csv.getSize(df));
    showLog('Countries:', groups.groupValues.length);
    showLog('Nation Offsets', [...inits.offsets]);

    const uniformCfg = UniformAdapter.create([
      { type: 'u32', size: 4, init: 25, name: 'year_per_country' },
      { type: 'u32', size: 4, init: size, name: 'observations' },
      { type: 'u32', size: 4, init: inits.size, name: 'countries' },
      { type: 'u32', size: 4, init: 10, name: 'ralph_newton_iterations' },
    ]);

    const uniformExo = UniformAdapter.create([
      { type: 'f32', size: 4, init: 2/3, name: 'alpha' },
      { type: 'f32', size: 4, init: 0.4, name: 'saving' },
      { type: 'f32', size: 4, init: 0.07, name: 'depreciation' },
      { type: 'f32', size: 4, init: INITIAL_TECH, name: 'tech_init' },
    ]);

    const uniformEff = UniformAdapter.create([
      { type: 'f32', size: 4, init: 0.001, name: 'phoneEffect' },
      { type: 'f32', size: 4, init: 0.001, name: 'phoneInternet' },
    ]);

    device.pushErrorScope('validation');

    const { COPY_DST, COPY_SRC } = GPUBufferUsage;
    const bufferNationOffset = createBuffer(device, inits.offsets, COPY_DST);
    const bufferNationCapitalInit = createBuffer(device, inits.capital, COPY_DST);

    // Combined output buffer: struct has 4 f32s per row (technology, capital, capital_steady_state, output)
    const combinedOutputData = new Float32Array(new Array(size * 5).fill(0));
    const bufferCombinedOutput = createBuffer(device, combinedOutputData, COPY_SRC | COPY_DST);

    const bufferPhoneUsage = createBuffer(device, df.phoneUsageD, COPY_DST);
    const bufferPhoneInternet = createBuffer(device, df.phoneInternetD, COPY_DST);
    const bufferUnemployment = createBuffer(device, df.unemployment, COPY_DST);
    const bufferLabourForce = createBuffer(device, df.labourForce, COPY_DST);
    const bufferUnifExo = uniformExo.createBuffer(device);
    const bufferUnifEff = uniformEff.createBuffer(device);
    const bufferUnifCfg = uniformCfg.createBuffer(device);

    const uniformBindGrp = [
      { binding: 0, resource: { buffer: bufferUnifExo } },
      { binding: 1, resource: { buffer: bufferUnifEff } },
    ];

    const shaderCode = document.getElementById('compute-shader').textContent;
    const shaderModule = device.createShaderModule({ code: shaderCode });

    const step1 = createStep({
      device,
      shaderModule,
      uniforms: [
        { binding: 0, resource: { buffer: bufferUnifExo } },
        { binding: 1, resource: { buffer: bufferUnifEff } },
        { binding: 2, resource: { buffer: bufferUnifCfg } },
      ],
      workGroups: inits.size,
      entryPoint: 'step1',
      entries: [
        { binding: 0, resource: { buffer: bufferNationOffset } },
        { binding: 1, resource: { buffer: bufferNationCapitalInit } },

        { binding: 10, resource: { buffer: bufferCombinedOutput } },

        { binding: 20, resource: { buffer: bufferPhoneUsage } },
        { binding: 21, resource: { buffer: bufferPhoneInternet } },

        { binding: 30, resource: { buffer: bufferUnemployment } },
        { binding: 31, resource: { buffer: bufferLabourForce } },
      ],
    });

    const step2 = createStep({
      device,
      shaderModule,
      uniforms: [
        { binding: 0, resource: { buffer: bufferUnifExo } },
        { binding: 2, resource: { buffer: bufferUnifCfg } },
      ],
      workGroups: Math.ceil(size / 64),
      entryPoint: 'step2',
      entries: [
        { binding: 10, resource: { buffer: bufferCombinedOutput } },
        { binding: 30, resource: { buffer: bufferUnemployment } },
        { binding: 31, resource: { buffer: bufferLabourForce } },
      ],
    });

    showLog('running GPU');
    await runGPU();
    console.log(df);

    const errorScope = await device.popErrorScope();
    if (errorScope) {
      console.error('GPU:',errorScope.message);
      showLog('error', errorScope.message);
      console.info(errorScope);
    } else {
      showLog('done');
    }

    async function runGPU() {
      try {
        const commandEncoder = device.createCommandEncoder();
        const pass = commandEncoder.beginComputePass();
        step1.loadIntoPass(pass);
        step2.loadIntoPass(pass);
        pass.end();

        const mapping = createMapping(
          device,
          commandEncoder,
          bufferCombinedOutput,
          combinedOutputData,
        );

        device.queue.submit([commandEncoder.finish()]);
        await mapping.read();

        for (let i = 0; i < size; i++) {
          df.technology[i] = combinedOutputData[i * 5 + 0];
          df.capital[i] = combinedOutputData[i * 5 + 1];
          df.capitalSteadyState[i] = combinedOutputData[i * 5 + 2];
          df.output[i] = combinedOutputData[i * 5 + 3];
          df.employed[i] = combinedOutputData[i * 5 + 4]
        }

        showLog('Output results:', [...df.output.slice(0, 10)]);
        showLog('Captial results:', [...df.capital.slice(0, 10)]);
        showLog('Employed results:', [...df.employed.slice(0, 10)]);
        showLog('Technology results:', [...df.technology.slice(0, 10)]);
        showLog('Capital steady state results:', [...df.capitalSteadyState.slice(0, 10)]);
        console.info(df, groups);
      } catch (e) {
        console.error(e);
      }
    }

    async function onMessage(event) {
      try {
        const message = event.data;
        switch (message.kind) {
          case 'action':
            return await onAction(message);

          case 'update-knobs':
            return updateUniforms(message.data)

          default:
            return console.log('unknown message', message);
        }
      } catch (e) {
        console.error(e);
      }
    }

    async function updateUniforms(data) {
      console.log(data);
      uniformExo.update('alpha', data.alpha);
      uniformExo.update('saving', data.saving);
      uniformExo.update('depreciation', data.depreciation);
      uniformExo.update('tech_init', data.technology);
      uniformEff.update('phoneEffect', data.phoneEffect);
      uniformEff.update('phoneInternet', data.phoneInternet);
      uniformExo.updateBuffer(device, bufferUnifExo);
      uniformEff.updateBuffer(device, bufferUnifEff);
      await runGPU();
      showLog('done');
    }

    async function onAction(message) {
      switch (message.id) {
        case 'download-inputs':
          return await csv.downloadFile(
            csv.renameColumn(
              csv.dropColumn(df, [
                'countryId',
                'technology',
                'capitalSteadyState',
                'capital',
                'output',
              ]),
              {
                generatedData: 'faked_askAngusWhatThatMeans',
                phoneUsageD: 'difference_in_phoneUsage',
                phoneInternetD: 'difference_in_phoneInternet',
              },
            ),
            'model-inputs.csv',
          );

        case 'download-all':
          return await csv.downloadFile(
            csv.renameColumn(
              csv.dropColumn(df, [
                'countryId',
              ]),
              {
                generatedData: 'faked_askAngusWhatThatMeans',
                phoneUsageD: 'difference_in_phoneUsage',
                phoneInternetD: 'difference_in_phoneInternet',
              },
            ),
            'all-model-data-points.csv',
          );

        default:
          return console.log('unknown action', message);
      }
    }

    function showLog(...args) {
      window.parent?.postMessage({ kind: 'push-log', log: args });
    }

    /**
     * Setup data for processing
     */
    async function setupData() {
      const fetching = {
        loadWideData(cfg) {
          return fetch(cfg.url)
              .then(r => r.text())
              .then(t => csv.processCsv(t, {
                headers: cfg.headers.load,
                dropRows: cfg.dropRows ?? 0,
              }))
              .then(df => {
                const { retain, colout } = cfg.headers.long;
                return csv.wideToLong(df, retain, colout);
              })
        },
        loadLongData(cfg) {
          return fetch(cfg.url)
              .then(r => r.text())
              .then(t => csv.processCsv(t, {
                headers: cfg.headers,
                dropRows: cfg.dropRows ?? 0,
              }))
        },
        loadItuData(cfg) {
          return fetching.loadLongData(cfg)
              .then(df => csv.filter(df, 'seriesCode', y => y === cfg.seriesCode))
              .then(df => csv.dropColumn(df, 'seriesCode'))
              .then(df => csv.renameColumn(df, { value: cfg.dataName }))
        },
      };

      const columnsThatNeedCleaning = [
        'capitalPPP', 'labourForce', 'phoneInternet',
        'phoneUsage', 'population', 'unemployment',
      ];
      const columnsThatNeedRepeating = ['countryId', 'countryIso', 'countryName'];

      const [
        ituPhone,
        ituMobileInternet,
        wbPop,
        wbLabourForce,
        wbUnemployment,
        pwtStock,
      ] = await Promise.all([
        fetching.loadItuData(datasets.ituCellPhones),
        fetching.loadItuData(datasets.ituMobileBoardBandSubcriptions),
        fetching.loadWideData(datasets.wbPopulation),
        fetching.loadWideData(datasets.wbLabourForce),
        fetching.loadWideData(datasets.wbUnemployment),
        fetching.loadWideData(datasets.pwtCapitalStock),
      ]);

      let join = csv.outerJoins(
        [ituPhone, ituMobileInternet, wbPop, wbLabourForce, wbUnemployment, pwtStock],
        ['countryIso', 'year'],
      );
      join = csv.filter(join, 'year', year => !Number.isNaN(year) && year > 1999);
      let joinGroup = csv.sortAndIdentifyGroups('countryIso', 'year', join);
      joinGroup = csv.filterGroups(joinGroup, { uniformSize: true }, meta => {
        if (meta.max < 2012 || meta.count < 10) return false;

        const join = joinGroup.frame;
        const { count, offset } = meta;
        for (const colname of columnsThatNeedCleaning) {
          const input = join[colname];
          let nans = 0;
          for (let i = 0; i < count; i++) {
            if (Number.isNaN(input[offset + i])) nans += 1;
          }
          if (nans >= (count - nans)) return false;
        }

        return true;
      });


      joinGroup = csv.sortAndIdentifyGroups('countryIso', 'year', joinGroup.frame);
      join = joinGroup.frame;

      const size = csv.getSize(join);
      join.technology = new Float32Array(size);
      join.capitalSteadyState = new Float32Array(size);
      join.employed = new Float32Array(size);
      join.capital = new Float32Array(size);
      join.output = new Float32Array(size);

      join.phoneUsageD = new Float32Array(size);
      join.phoneInternetD = new Float32Array(size);
      join.generatedData = new Array(size).fill('');

      /**
       * Clean up the data may not be complete
       */
      for (const colname of columnsThatNeedCleaning) {
        const input = join[colname];
        for (const [groupValue, { offset, count }] of joinGroup.groups.entries()) {
          if (Number.isNaN(input[offset])) {
            input[offset] = 0;
            join.generatedData[offset] += ':'+colname
          }
          for (let i = 1; i < count; i++) {
            let idx = offset + i;
            if (Number.isNaN(input[idx])) {
              join.generatedData[idx] += ':'+colname
              input[idx] = input[idx-1];
              if (Number.isNaN(input[idx])) debugger;
            }
          }
        }
      }

      for (const [diff, sum] of [
        [join.phoneUsageD, join.phoneUsage],
        [join.phoneInternetD, join.phoneInternet],
      ]) {
        for (const [groupValue, { offset, count }] of joinGroup.groups.entries()) {
          diff[offset] = sum[offset];
          for (let i = 1; i < count; i++) {
            diff[offset + i] = sum[offset + i] - sum[offset + i - 1];
          }
        }
      }

      const initCapital = Array.from(joinGroup.groups.keys(), country => {
        const index = csv.findIndex(pwtStock, [
          ['year', year => year === 1999],
          ['countryIso', iso => iso === country],
        ]);
        return pwtStock.capitalPPP[index];
      });

      const offsets = Array.from(joinGroup.groups.values(), row => row.offset);

      const initalValues = {
        capital: new Float32Array(initCapital),
        offsets: new Uint32Array(offsets),
        size: offsets.length,
      };
      return [size, joinGroup, join, initalValues];
    }
  </script>
  <script type="text/wgsl" id="compute-shader">
    struct Config {
      year_per_country: u32,
      observations: u32,
      countries: u32,
      ralph_newton_iterations: u32,
    };

    struct Effects {
      phone_fixed: f32,
      net_exp: f32,
    };

    struct ExogenousState {
      alpha: f32,
      saving: f32,
      depreciation: f32,
      tech_init: f32,
    };

    struct ComputedState {
      technology: f32,
      capital: f32,
      capital_steady_state: f32,
      output: f32,
      employed: f32,
    }

    @group(1) @binding(0) var<uniform> exo: ExogenousState;
    @group(1) @binding(1) var<uniform> effects: Effects;
    @group(1) @binding(2) var<uniform> config: Config;

    @group(0) @binding(0) var<storage, read> offsets: array<u32>;
    @group(0) @binding(1) var<storage, read> capital_init: array<f32>;

    @group(0) @binding(10) var<storage, read_write> out: array<ComputedState>;

    @group(0) @binding(20) var<storage, read> growth_phoneuse: array<f32>;
    @group(0) @binding(21) var<storage, read> growth_netuse: array<f32>;
    @group(0) @binding(30) var<storage, read> unemployment: array<f32>;
    @group(0) @binding(31) var<storage, read> labourForce: array<f32>;

    /**
     * Uses ralph newton to solve for capital
     * https://en.wikipedia.org/wiki/Newton%27s_method
     *
     * - Basically inline Y into K, creating a simulatenous equation
     * - Move everything on to one side where the other side is zero
     * - Turn the left hand side into a function that takes K as param
     * - Then get a derivative by deriving it by K
     *
     * Knowing this we can brute force different values of K until
     * we get a function that produces zero or a sufficently small
     * number that we are're satisified.
     */
    fn ralph_newton_capital(k_last: f32, tech: f32, labour: f32) -> f32 {
      var k_init = k_last;
      if (k_last < 0 || k_last != k_last) { k_init = 1.0; }
      if (tech <= 0 || labour <= 0) { return k_init; }

      var k = max(k_init, 1.0);
      let base_term = k_last * (1.0 - exo.depreciation);
      let coeff = exo.saving * tech * pow(labour, exo.alpha);

      for (var i = 0u; i < config.ralph_newton_iterations; i++) {
        let k_pow_beta = pow(k, 1.0 - exo.alpha);
        let k_pow_neg_alpha = pow(k, -exo.alpha);
        let f = k - coeff * k_pow_beta - base_term;
        let f_prime = 1.0 - coeff * (1.0 - exo.alpha) * k_pow_neg_alpha;

        if (abs(f_prime) < 1e-8) { break; }

        let k_new = k - f / f_prime;
        let k_safe = max(k_new, 0.1);

        if (abs(k_safe - k) < 1e-6 * abs(k)) {
          return k_safe;
        } else {
          k = k_safe;
        }
      }

      return k;
    }

    /**
     * Computes the steady state at `t` for
     *
     * K(t) = Labour * ((saving*technology)/depreciation)^(1/alpha)
     */
    fn capital_steady_state_at(t: u32) -> f32 {
      let numer = exo.saving * out[t].technology;
      let denom = exo.depreciation;
      return out[t].employed * pow(numer/denom, 1.0/exo.alpha);
    }

    /**
     * Compute Output, Capital, Technology, Labour at period t.
     */
    fn compute_yktl_at(t: u32, last_tech: f32, last_kaptial: f32) -> vec4<f32> {
      let a_growth_phone = growth_phoneuse[t] * effects.phone_fixed;
      let a_growth_net = growth_netuse[t] * effects.net_exp;
      let a = a_growth_phone + a_growth_net + last_tech;
      let l = labourForce[t] * (100.0 - unemployment[t]) * (1.0/100.0);
      let k = ralph_newton_capital(last_kaptial, a, l);
      let y = a * pow(l, exo.alpha) * pow(k, 1 - exo.alpha);
      return vec4(y, k, a, l);
    }

    /**
     * Computes technology over the different periods
     */
    @compute @workgroup_size(1)
    fn step1(@builtin(global_invocation_id) global_id: vec3<u32>) {
      if (global_id.x >= config.countries) { return; }
      let offset: u32 = offsets[global_id.x];
      var last_k: f32 = capital_init[global_id.x];
      var last_t: f32 = exo.tech_init;

      for (var i = 0u; i < config.year_per_country; i++) {
        let idx = offset + i;
        let yktl = compute_yktl_at(idx, last_t, last_k);
        last_k = yktl.y;
        last_t = yktl.z;
        out[idx].output = yktl.x;
        out[idx].capital = yktl.y;
        out[idx].technology = yktl.z;
        out[idx].employed = yktl.w;
      }
    }

    @compute @workgroup_size(64)
    fn step2(@builtin(global_invocation_id) global_id: vec3<u32>) {
      let idx = global_id.x;
      if (idx >= config.observations) { return; }

      out[idx].capital_steady_state = capital_steady_state_at(idx);
    }
  </script>
  <template id="model-syntax">
    <h1>TFP growth via Phones & Internet</h1>
    <math display="block">
      <mover>
        <mtable>
          <mtr>
            <mtd columnalign="right"><msub><mi>A</mi><mi>t</mi></msub></mtd>
            <mtd><mo>=</mo></mtd>
            <mtd columnalign="left">
              <msub>
                <mi>A</mi>
                <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow>
              </msub>
              <mo>+</mo>
              <mrow>
                <mi>ùõΩ</mi>
                <mo>¬∑</mo>
                <msub><mi>ùúë</mi><mi>t</mi></msub>
              </mrow>
              <mo>+</mo>
              <mrow>
                <mi>ùõæ</mi>
                <mo>¬∑</mo>
                <msub><mi>ùúì</mi><mi>t</mi></msub>
              </mrow>
            </mtd>
          </mtr>
          <mtr>
            <mtd columnalign="right"><msub><mi>K</mi><mi>t</mi></msub></mtd>
            <mtd><mo>=</mo></mtd>
            <mtd columnalign="left">
              <mrow>
                <msub>
                  <mi>K</mi>
                  <mrow><mi>t</mi><mo>-</mo><mn>1</mn></mrow>
                </msub>
                <mo>¬∑</mo>
                <mrow>
                  <mo>(</mo>
                  <mrow><mn>1</mn><mo>-</mo><mi>ùõø</mi></mrow>
                  <mo>)</mo>
                </mrow>
              </mrow>
              <mo>+</mo>
              <mrow>
                <mi>s</mi>
                <mo>¬∑</mo>
                <msub><mi>Y</mi><mi>t</mi></msub>
              </mrow>
            </mtd>
          </mtr>
          <mtr>
            <mtd columnalign="right"><msub><mi>Y</mi><mi>t</mi></msub></mtd>
            <mtd><mo>=</mo></mtd>
            <mtd columnalign="left">
              <msub><mi>A</mi><mi>t</mi></msub>
              <mo>¬∑</mo>
              <msubsup>
                <mi>L</mi>
                <mi>t</mi>
                <mi>ùõº</mi>
              </msubsup>
              <mo>¬∑</mo>
              <msubsup>
                <mi>K</mi>
                <mi>t</mi>
                <mrow><mn>1</mn><mo>-</mo><mi>ùõº</mi></mrow>
              </msubsup>
            </mtd>
          </mtr>
        </mtable>
        <mover><mo>‚èû</mo><mtext>TFP with Fixed effects growth</text></mover>
      </mover>
    </math>
    <h2>About</h2>
    <p>
      This model assumes all countries have TFP of 1000 at the start
      (almost certianly incorrect), and this might be to explain for
      the dramatically incorrect results for capital and output.
    </p>
  </template>
</body>
</html>
